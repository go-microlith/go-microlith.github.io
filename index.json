[
{
	"uri": "http://microlith-framework.com/examples/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " The complete code from the tutorial is available in the  tutorial.com repository.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/tutorial.com.\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; git clone https://github.com/go-microlith/tutorial.com \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/tutorial.com/.git/\u0026quot; # Build the application go install tutorial.com  Bootstrap Assuming you own the domain name my-domain.com hosted in zone Z1234567890, use:\ntutorial.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name tutorial.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name tutorial.com.prod.my-domain.com  API The APIs for each subdomain are documented below.\nThis application is deployed live at https://tutorial.com.prod.microlith-framework.com\n Root Domain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, world!\u0026rdquo;   GET /proxy/to/subdomain Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    Subdomain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    "
},
{
	"uri": "http://microlith-framework.com/design/microservices/",
	"title": "Microservices",
	"tags": [],
	"description": "",
	"content": " Microlith uses a microservices-based model called the Domain model. It has three main concepts: Services, Domains, and Applications.\nServices Services are atomic units of business logic and are the base building block of a Microlith application.\nServices are implemented as AWS::Serverless services, containing resources such as Buckets, Tables, and Streams to store and communicate state.\nA service\u0026rsquo;s external interface is a REST API. Endpoints on the API implement business logic by manipulating buckets, mutating tables, and publishing to streams.\nAsynchronous business logic such as observing objects in a bucket, watching changes to tables, and processing events published to a stream is implemented by attaching Lambdas to resources. Services additionally support non-resource actions, such as scheduling cron jobs and reading Lambdas\u0026rsquo; logs.\nUnlike a standard AWS::Serverless service, the API is not publicly routable. Microlith services must live in a container that makes calls on them, such as a Domain or Application.\nDomains Domains are containers for services. They compose the business logic of the services to build larger, richer, and more complex units of business logic.\nA domain\u0026rsquo;s external interface is a REST API mounted under a publicly routable DNS name. Endpoints on this API, named the Origin, implement business logic by making calls on the services in the domain.\nServices themselves cannot make calls on their peers in the domain. To coordinate between them, domains provide broadcast Channels. Channels are streams that are shared between all of the services in a domain. Any service can publish events to a channel and/or process events published to a channel.\nApplications Applications are containers for domains. They route traffic to domains and share state between domains. Each Microlith application is a single Application container.\nApplications route traffic using DNS. Every application contains at least one domain, called the Root domain. This domain is mounted under a base DNS name, such as \u0026ldquo;example.com\u0026rdquo;. Applications can contain named subdomains which are mounted relative to the DNS name of root domain, such as \u0026ldquo;foo.example.com\u0026rdquo;, \u0026ldquo;bar.example.com\u0026rdquo;, and \u0026ldquo;foo.bar.example.com\u0026rdquo;.\nTo coordinate between domains, applications provide Globals. The globals are a set of services and channels that make a \u0026ldquo;pseudo-domain\u0026rdquo; that is shared between all domains. Origins can call global services just like their internal services, and services can use global channels just like normal channels. Unlike peer services in a domain, Global services can be called directly by services in a domain.\n"
},
{
	"uri": "http://microlith-framework.com/resources/blob/",
	"title": "Buckets",
	"tags": [],
	"description": "",
	"content": " Microlith supports S3 Buckets.\nCreate a Bucket Create a bucket by calling Bucket() on a service builder with a unique bucket name.\nimages := service.Bucket(\u0026quot;images\u0026quot;)  The returned object is used to create clients and to attach observers.\n"
},
{
	"uri": "http://microlith-framework.com/resources/stor/mutator/crud/",
	"title": "CRUD Operations",
	"tags": [],
	"description": "",
	"content": " Mutators support CRUD operations on individual items. Every operation takes a key to identify the object to operate on and/or a value. These keys and values can be either non-nil map[string]interface{} values or structs. If a value is used as a key, it must include the key fields specified when the table is created.\nPut The Put() inserts or overwrites a value in the table. The item passed must include the key fields.\nfor _, album := range []Album{suchSweetThunder, threeSuites, aLoveSupreme} { if err := mutator.Put(ctx, album); err != nil { log.Panic(err) } }  Get The Get() operation fetches a single item from the table. The key value must contain the key fields. You must provide a value to deserialize the fetched item, if found.\nkey := Album{ Name: \u0026quot;Three Suites\u0026quot;, Artist: \u0026quot;Duke Ellington and His Orchestra\u0026quot;, } var value Album found, err := mutator.Get(ctx, key, \u0026amp;value) if err != nil { log.Panic(err) }  Update The Update() operation mutates an existing item in-place. The update operation always requires passing a builder so the attributes to update can be given as an expression.\nthreeSuites.Year = 1990 threeSuites.UpdatedAt = time.Now() if err := mutator.Update(ctx, threeSuites, func(update *Update) { update.Update( expression. Set(expression.Name(\u0026quot;Year\u0026quot;), expression.Value(threeSuites.Year)). Set(expression.Name(\u0026quot;UpdatedAt\u0026quot;), expression.Value(threeSuites.UpdatedAt)), ) }); err != nil { log.Panic(err) }  Delete The Delete() operation removes an item from the table.\nif err := mutator.Delete(ctx, suchSweetThunder); err != nil { log.Panic(err) }  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/go_get/",
	"title": "Get Microlith",
	"tags": [],
	"description": "",
	"content": "Microlith is a standard Go library. Just use \u0026ldquo;go get\u0026rdquo;:\ngo get gopkg.in/microlith.v0  "
},
{
	"uri": "http://microlith-framework.com/tutorial/root/",
	"title": "Hello, world!",
	"tags": [],
	"description": "",
	"content": " We will start by adding a single \u0026ldquo;Hello, world!\u0026rdquo; endpoint to our application and redeploying. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level \u0026ldquo;microlith\u0026rdquo; package.\nThe Handler First, we will create a handler function. The handler function must match the signature of a API Gateway Lambda. The body of the handler uses the Respond() helper to return a 200 response code and the string \u0026ldquo;Hello, world!\u0026rdquo; This helper automatically encodes the response body as JSON.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Hello, world!\u0026quot;) }  The Endpoint Next, we will add a single endpoint at \u0026ldquo;GET /\u0026rdquo; named \u0026ldquo;hello-world\u0026rdquo; and pass the handler function.\nTo define endpoints on the origin, use the microlith.Scope() function. This function takes a path and a builder that provides a Swagger-based DSL for defining a REST API. Endpoints are defined using methods named after HTTP verbs (such as Get(), Put(), etc.) For each endpoint defined, you must pass a unique name and a handler function.\nfunc init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;hello-world\u0026quot;, handler) }) }  Ship It That\u0026rsquo;s all there is to adding an endpoint. Now you are ready to deploy your app:\ngit add . git commit -m \u0026quot;Added my first endpoint\u0026quot; git push origin master  Once your application has deployed, you can make requests against your endpoint:\ncurl https://prod.my-domain.com/  You should receive a response of \u0026ldquo;Hello, world!\u0026rdquo;\nFreshly deployed Lambdas perform a cold start when the first request is received. When manual testing, you application may return a 500 Internal Server Error on the first few requests after deployment until the Lambdas warm up. If it does, wait a few seconds and retry the request a couple of times until it returns the expected response.\n "
},
{
	"uri": "http://microlith-framework.com/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Microlith is a batteries-included AWS::Serverless framework for Go.\n Zero YAML Zero configuration (*) Simple API Powerful service-oriented model Secure, best-practices testing and production environments \u0026ldquo;Push to prod\u0026rdquo; Continuous Deployment  The documentation will take you through bootstrapping your first application, briefly introduce Microlith\u0026rsquo;s design, and then take you through a guided tutorial of using Microlith.\nQuestions? Problems? Email the list at go-serverless@microlith-framework.com\n"
},
{
	"uri": "http://microlith-framework.com/examples/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": " A blogging application with social features is available in the  blog.com repository.\nIt provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (\u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, etc.) on both posts and comments.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/blog.com:\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/blog.com\u0026quot; git clone https://github.com/go-microlith/blog.com \u0026quot;${GOPATH}/src/blog.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/blog.com/.git/\u0026quot; # Build the application go install blog.com  Bootstrap blog.com bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name blog.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name blog.com.prod.my-domain.com  API This application is deployed live to https://blog.com.prod.microlith-framework.com/\n Root Domain    Method URL Example Request Body Description     GET /posts N/A Get all blog posts with comments and reactions   POST /posts {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The post body\u0026rdquo;} Create a blog post   GET /posts/{post-id} N/A Get a specific blog post   PUT /posts/{post-id} {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;Updated body\u0026rdquo;} Update the contents of a blog post   DELETE /posts/{post-id} N/A Delete a specific blog post   POST /posts/{post-id}/like N/A React to a blog post with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/love N/A React to a blog post with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/haha N/A React to a blog post with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/wow N/A React to a blog post with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/sad N/A React to a blog post with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/angry N/A React to a blog post with a \u0026ldquo;Angry\u0026rdquo;   POST /posts/{post-id}/comments {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The comment\u0026rdquo;} Comment on a blog post   POST /posts/{post-id}/comments/{comment-id}/like N/A React to a comment with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/love N/A React to a comment with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/haha N/A React to a comment with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/wow N/A React to a comment with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/sad N/A React to a comment with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/angry N/A React to a comment with a \u0026ldquo;Angry\u0026rdquo;    Implementation This application is implemented with a single service in the root domain, two global services, and a global channel.\nThe posts service in the root domain provides CRUD operations on blog posts. It is backed by a single DynamoDB table to store the posts.\nThe comments global service provides the ability to comment on an object and to fetch all of the comments on an object. It is backed by a single DynamoDB table to store the comments. The table has a global secondary index to fetch time-ordered comments on a single object.\nThe reactions global service provides the ability to react to an object and to fetch a summary of the reactions to an object. It is backed by a single DynamoDB table to store the reactions. It lives in the blog.com/reactions package.\nThe object-deleted global channel contains events with the IDs of objects that were deleted. The posts service watches its DynamoDB table for deletes and emits an event on the channel when one is detected. The comments and reactions service processes the channel and purges any comments on and reactions to the deleted objects. The comments service also watches its DynamoDB table for deletes and emits events on the channel so that reactions to comments are also deleted.\nThe origin provides a complete API for the user. The list-posts endpoint fetches the posts along with their comments and reactions to return them to the user. The rest of the endpoints are proxies to service endpoints to interact with the returned posts.\n"
},
{
	"uri": "http://microlith-framework.com/design/monolith/",
	"title": "Monolith",
	"tags": [],
	"description": "",
	"content": " Microlith packages an entire application into a single executable binary. It does this by taking advantage of the init/main phase distinction in Go.\nInit Phase Microlith represents a Domain model application as a tree of Go objects. During the init phase, Microlith provides a builder DSL to construct this tree. Lambda functions are given as Go callback functions. The init phase ends when microlith.Main() is called.\nThe init phase must build this tree deterministically. Microlith relies on every running instance of the executable having an identical copy of this tree. Non-determinism leads to undefined behavior.\nThe init phase will be run on every process start in multiple environments. It must not perform operations requiring external dependencies such as I/O, and should avoid complex, time-consuming algorithms.\nThe init phase must fail fast. Any errors encountered by Microlith during this phase will result in a panic(). Any user errors should likewise result in a panic, and any calls to recover() should re-panic.\nMain Phase The main phase of the executable is completely controlled by the framework. The call to microlith.Main() inverts control and never returns it to the user. The only user code called during the main phase are the callbacks provided during the init phase.\nMicrolith deploys each callback as a separate Lambda function. Each function must be designed as if it was in a stand-alone executable and must not must not share mutable runtime state between functions. For example, mutating a shared variable in one function will not be reflected in other functions.\nBecause AWS Lambda can start and stop function processes at will, all non-local state must be considered transient between requests. For example, incrementing a private counter variable on every request will not behave as expected. All Lambdas must assume they are processing the first and only request.\n"
},
{
	"uri": "http://microlith-framework.com/resources/rest/call/",
	"title": "Call an API",
	"tags": [],
	"description": "",
	"content": "Call APIs by creating a Client and calling the Call() method. This takes the endpoint to call and an optional request body for non HEAD and GET requests. Call() can be passed an optional request builder to set the path and query parameters and request headers. The Call() method returns a standard http.Response.\nrequestBody := map[string]interface{}{\u0026quot;Foo\u0026quot;: \u0026quot;bar\u0026quot;} responseBody := map[string]interface{}{} // Construct a new client var client = NewClient(\u0026quot;http://localhost:8080/\u0026quot;) // Call an endpoint resp, err := client.Call(echoEndpoint, requestBody, func(request *Request) { request.QueryParameter(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;) request.Header(\u0026quot;x-foo\u0026quot;, \u0026quot;bar\u0026quot;) }) if err != nil { log.Panic(err) }  Use the ResponseBody() and ErrorResponse() helpers to parse the response. ResponseBody() parses the response body as JSON. ErrorResponse() creates an error out of the \u0026lsquo;X-Microlith-Error\u0026rsquo; header. If the second argument to ErrorResponse() is a non-nil error, the response body is deserialized into it.\nswitch resp.StatusCode { case http.StatusOK: if err := ResponseBody(resp, \u0026amp;responseBody); err != nil { log.Panic(err) } default: err := ErrorResponse(resp, nil) log.Panic(err) }  "
},
{
	"uri": "http://microlith-framework.com/resources/strm/publisher/",
	"title": "Publishing to Streams",
	"tags": [],
	"description": "",
	"content": "To publish to a stream, create a Publisher object and Publish() messages. The publisher automatically encodes the messages to JSON and batches messages before sending. Be sure to Flush() your publisher to ensure the final batch is sent.\n// Create a publisher var publisher = NewPublisher(userSignups) func someHandler(ctx context.Context) error { // Be sure to Flush() the publisher defer publisher.Flush(ctx) // Write messages to the stream if err := publisher.Publish(ctx, \u0026quot;partition-one\u0026quot;, \u0026quot;value-one\u0026quot;); err != nil { return err } return publisher.Publish(ctx, \u0026quot;partition-two\u0026quot;, \u0026quot;value-one\u0026quot;, \u0026quot;value-two\u0026quot;) }  Streams are created with an AWS-assigned stream name. This name is available at runtime via the StreamName() function.\nclient := kinesis.New(session.New()) streamName := StreamName(userSignups) client.PutRecords(\u0026amp;kinesis.PutRecordsInput{ StreamName: aws.String(streamName), // ... })  "
},
{
	"uri": "http://microlith-framework.com/resources/stor/mutator/query/",
	"title": "Query Operations",
	"tags": [],
	"description": "",
	"content": "The Query and Scan operations operate a page of results at a time. They return a Result object to process the items in the results.\n// Query the first page of results from the table result, err := mutator.Query(ctx, func(query *Query) { query.KeyCondition( expression.Name(\u0026quot;Foo\u0026quot;).Equal(expression.Value(\u0026quot;bar\u0026quot;)), ) }) if err != nil { log.Panic(err) }  To fetch and process all of the pages, the Result object contains the last evaluated key\n// Scan the entire table into an array var results []map[string]interface{} result, err := mutator.Scan(ctx) for { if err != nil { log.Panic(err) } for result.Next() { var result map[string]interface{} if err := result.Scan(result); err != nil { log.Panic(err) } results = append(results, result) } if result.LastEvaluatedKey() == nil { break } result, err = mutator.Scan(ctx, func(scan *Scan) { scan.ExclusiveStartKey(result.LastEvaluatedKey()) }) }  "
},
{
	"uri": "http://microlith-framework.com/tutorial/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Services implement the business logic of your Microlith application.\nLet\u0026rsquo;s refactor our domain into a pair of services: a \u0026ldquo;hello\u0026rdquo; and a \u0026ldquo;world\u0026rdquo; service. Then we\u0026rsquo;ll refactor our origin endpoint to call those services to build a response.\nCreate a Service We will create a \u0026ldquo;word\u0026rdquo; service that returns a fixed word. At the code level, a service is an object which implements the tld.ServiceBuilder interface.\n// Word is a service that returns a fixed word type Word struct { word string client *rest.Client endpoint *rest.Endpoint } // NewWord constructs an instance of the \u0026quot;word\u0026quot; service returning the word. func NewWord(word string) *Word { return \u0026amp;Word{ word: word, } } // Build implements the tld.ServiceBuilder interface. func (word *Word) Build(service *tld.Service) { // TODO }  Add An Endpoint The word service will have one endpoint that responds with the word as JSON.\nTo add an endpoint, use the Scope() method on the service builder. We will capture the endpoint in an instance variable so we can use it in the next step.\nBuilder func (word *Word) Build(service *tld.Service) { service.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { word.endpoint = scope.Get(\u0026quot;word\u0026quot;, word.handler) }) }  Handler func (word *Word) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, word.word) }  Implement a Client To implement a client, add public methods to your service.\nTo make calls against your service, use the tld.ServiceClient() function create a rest.Client in your service builder. Use the client to Call() endpoints.\nBuilder func (word *Word) Build(service *tld.Service) { // ... Same as before ... var err error word.client, err = tld.ServiceClient(service) if err != nil { log.Panic(err) } }  Client Method // Word calls the \u0026quot;word\u0026quot; endpoint. On success, it returns the word. Otherwise, // it returns an error. func (word *Word) Word(ctx context.Context) (string, error) { resp, err := word.client.Call(ctx, word.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Refactor the Root Domain Now that we have a \u0026ldquo;word\u0026rdquo; service, we can use it in our origin to factor out our business logic.\nWe will create two instances of the service returning \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo;. Then, we will call those from our origin to construct our response.\nRegister the Services First, you must create and register the services with your domain using the microlith.Service() function.\nvar ( helloSvc = NewWord(\u0026quot;hello\u0026quot;) worldSvc = NewWord(\u0026quot;world\u0026quot;) ) func init() { // ... Same as before ... microlith.Service(\u0026quot;hello\u0026quot;, helloSvc) microlith.Service(\u0026quot;world\u0026quot;, worldSvc) }  Handler Next, use your the client methods on your service object to call the services. Construct a response to the user from the responses to the service calls.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloWorld := fmt.Sprintf(\u0026quot;%s, %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloWorld) }  Ship It You should be ready to deploy.\ngit add . git commit -m \u0026quot;Factored into services\u0026quot; git push origin master  Once deployed, you can make requests against your domain. You should see the same response as before.\ncurl https://prod.my-domain.com/  You might notice that this deploy takes longer than the last deploy. This is because Microlith uses safe Lambda deploys. By default, the test environment transitions traffic using the \u0026ldquo;AllAtOnce\u0026rdquo; configuration and the production environment uses the \u0026ldquo;Canary10Percent5Minutes\u0026rdquo; configuration. These are both configurable via the bootstrap process.\n "
},
{
	"uri": "http://microlith-framework.com/resources/strm/",
	"title": "Streams",
	"tags": [],
	"description": "",
	"content": "Create a stream by calling Stream() on a service builder:\nuserSignups := service.Stream(\u0026quot;user-signups\u0026quot;)  "
},
{
	"uri": "http://microlith-framework.com/resources/blob/manipulator/",
	"title": "Working with Buckets",
	"tags": [],
	"description": "",
	"content": " Objects are added, updated, and removed from a bucket using a Manipulator.\nCreate a manipulator by passing a reference to a bucket:\nmnip := blob.NewManipulator(images)  Get contents, err := mnip.Get(ctx, \u0026quot;/the/key\u0026quot;) if err != nil { log.Panic(err) } defer contents.Close()  io.Copy(os.Stdout, contents)  Put body, err := NewBufferString(\u0026quot;the-body\u0026quot;) if err != nil { log.Panic(err) } defer body.Close()  if err := mnip.Put(ctx, \u0026quot;/the/key\u0026quot;, body); err != nil { log.Panic(err) }  Delete if err := mnip.Delete(ctx, \u0026quot;/the/key\u0026quot;); err != nil { log.Panic(err) }  Bucket Name Buckets are created with an AWS-assigned bucket name. This name is available at runtime via the BucketName() function.\nclient := s3.New(session.New()) bucketName := BucketName(bucket) client.PutObject(\u0026amp;s3.PutObjectInput{ Bucket: aws.String(bucketName), // ... })  "
},
{
	"uri": "http://microlith-framework.com/resources/stor/mutator/",
	"title": "Working with Tables",
	"tags": [],
	"description": "",
	"content": " To interact with a table, create a Mutator. Mutators supports queries, scans, and CRUD operations. Batch operations on tables are supported using separate functions.\nmutator := stor.NewMutator(albums)  For indexes, create a Querier. This works identically to a Mutator but is limited to the Query() and Scan() operations only.\nalbumsByYearQuerier := stor.NewQuerier(albumsByYear) releaseOrderQuerier := stor.NewQuerier(releaseOrder)  Builders All operations on Mutators and Queriers support optional builders to refine the operations. This includes making reads consistent, making writes conditional, filtering query keys, and projecting fields into results. The methods on the builders take DynamoDB expression builders.\n"
},
{
	"uri": "http://microlith-framework.com/bootstrap/create/",
	"title": "Your First Application",
	"tags": [],
	"description": "",
	"content": " Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com.\nCreate an Application To create an application, create an executable in ${GOPATH}/src/example.com/main.go and call microlith.Main():\npackage main import ( microlith \u0026quot;gopkg.in/microlith.v0\u0026quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, \u0026ldquo;example.com\u0026rdquo;.\nThe import path of the source code is also significant to Microlith. By default, the main executable must live in the root of your repo at the root of your Go workspace\u0026rsquo;s source tree. In this case, \u0026ldquo;${GOPATH}/src/example.com\u0026rdquo;\nBuild Now, build your application:\ngo install example.com  Your application is now ready to be bootstrapped. Before you can do that, you need to set up Route53.\n"
},
{
	"uri": "http://microlith-framework.com/bootstrap/",
	"title": "Bootstrap",
	"tags": [],
	"description": "",
	"content": "Bootstrap will step you through getting your first Microlith application set up via the automated bootstrap process. By the end of the bootstrap, you will be able to \u0026ldquo;push to prod\u0026rdquo;:\n# Deploy your application git add . git commit -m \u0026quot;My changes\u0026quot; git push origin master # Use your test and production environments curl https://test.my-domain.com/ curl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " Design Microlith is a framework for building scaled, multi-service Software-as-a-Service (SaaS) applications. It simplifies writing and delivering these application by combining a microservice-based model with a monolithic application structure.\n"
},
{
	"uri": "http://microlith-framework.com/resources/stor/mutator/batch/",
	"title": "Batch Operations",
	"tags": [],
	"description": "",
	"content": " Batch operations on tables are supported via top-level functions.\nGet The operation retrieves multiple items from multiple tables at once.\nCreate Call the GetBatch() function and pass it a builder. Use the builder to Get() items from tables via their Keys(). You can use Consistent() reads and Project() only select attributes into the result.\nYou can perform up to 100 operations in a batch on one or more tables in a batch.\nresult, err := stor.GetBatch(ctx, func(batch *stor.BatchGet) { batch.Get(albums, func(get *stor.BatchGetGet) { get.Keys(threeSuites, aLoveSupreme) get.Project(expression.NamesList(expression.Name(\u0026quot;Artist\u0026quot;), expression.Name(\u0026quot;Name\u0026quot;), expression.Name(\u0026quot;Year\u0026quot;))) get.Consistent() }) }) if err != nil { log.Panic(err) }  The returned result provides Scanners to iterate over the retrieved items.\nscanner := result.Table(albums) for scanner.Next() { var album Album if err := scanner.Scan(\u0026amp;album); err != nil { log.Panic(err) } fmt.Printf(\u0026quot;%s released %q in %4d\u0026quot;, album.Artist, album.Name, album.Year) }  If not all of the reads completed, the result provides a More()/Continue() mechanism to complete the remaining reads.\nif result.More() { result, err = result.Continue(ctx) if err != nil { log.Panic(err) } }  Write The WriteBatch() operations performs multiple put and/or delete operations on multiple tables at once.\nresult, err := stor.WriteBatch(ctx, func(batch *stor.BatchWrite) { batch.Put(albums, suchSweetThunder) }) if err != nil { log.Panic(err) }  If not all of the writes completed, the results provides a More()/Continue() mechanism to complete the remaining writes.\nif result.More() { result, err = result.Continue(ctx) if err != nil { log.Panic(err) } }  "
},
{
	"uri": "http://microlith-framework.com/tutorial/channels/",
	"title": "Channels",
	"tags": [],
	"description": "",
	"content": " Channels are created by calling either the microlith.Channel() function to create a channel in the root domain, or by calling the microlith.Channel() method on a domain builder to create a channel in a subdomain. The returned reference can then be passed to a service so the service can interact with the channel.\nLet\u0026rsquo;s create a channel that logs an event when a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint in the Origin.\nCreate a Channel First, create the channel and an event type in the origin.\nvar requests = microlith.Channel(\u0026quot;requests\u0026quot;) type Request struct { At time.Time }  Refactor the Word Service Next, we need to pass the channel to the services that will use it and start processing events sent over the channel.\nUpdate the Constructor First, update the constructor for the word service so that it takes the channel as an argument.\ntype Word struct { // ... Same as before ... requests *strm.Stream } // NewWord constructs an instance of the \u0026quot;word\u0026quot; service that returns the word // and processes the requests channel. func NewWord(word string, requests *strm.Stream) *Word { return \u0026amp;Word{ word: word, requests: requests, } }  Process Events Next, process events on the channel by creating a strm.Processor in the builder. Implement a Kinesis Lambda method to handle the events. Use the Subscribe() method to subscribe to the channel.\nfunc (word *Word) Build(service *tld.Service) { // ... Same as before ... processor := service.Processor(\u0026quot;requests\u0026quot;, word.processRequests) processor.Process(word.requests, strm.StartingPositionTrimHorizon) } func (word *Word) processRequests(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { partitionKey := \u0026quot;\u0026quot; request := new(Request) if err := scanner.Scan(\u0026amp;partitionKey, request); err != nil { return err } log.Printf(\u0026quot;Request made at %s\u0026quot;, request.At.Format(time.RFC3339Nano)) } return nil }  Refactor the Root Domain Now that the services are updated to subscribe to the channel, we need to provide the channel to the services and start publishing events.\nUse the Updated Constructor Use the new constructors to pass the channel to the services.\nvar ( helloSvc = NewWord(\u0026quot;hello\u0026quot;, requests) worldSvc = NewWord(\u0026quot;world\u0026quot;, requests) )  Publish Events Finally, publish an event to the channel on every request. Be sure to always Flush() publishers to ensure that any batched messages are sent.\nvar publisher = strm.NewPublisher(requests) func handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { defer publisher.Flush(ctx) if err := publisher.Publish(ctx, \u0026quot;partition-key\u0026quot;, \u0026amp;Request{At: time.Now()}); err != nil { return rest.Respond(http.StatusInternalServerError, err) } // ... Same as before ... }  Ship It Now both services will process an event every time a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Added a channel\u0026quot; git push origin master  Make a request against your application and the processors will soon emit a message to their CloudWatch logs.\ncurl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/resources/blob/observer/",
	"title": "Observing Changes",
	"tags": [],
	"description": "",
	"content": " Observers are Lambda functions that observe buckets and are invoked when the buckets\u0026rsquo; contents change.\nObservers cannot access buckets. This is due to a circular dependency in CloudFormation. If an observer needs to access buckets, a work around is to publish all events to a Stream and create a processor to perform the action.\n Create an Observer Create an observer by calling the Observer() function on a service builder, giving it a unique observer name and an S3 Lambda function.\nimageAdded := service.Observer(\u0026quot;image-added\u0026quot;, func(ctx context.Context, evt events.S3Event) error { for _, record := range evt.Records { fmt.Printf(\u0026quot;Image %q added\u0026quot;, record.S3.Object.Key) } return nil })  Observe a Bucket To observe changes to the contents of a bucket, use the Observe() method on the Observer. This function can be called multiple times to observe multiple events on multiple buckets.\nimageAdded.Observe(images, blob.EventObjectCreated)  You can filter the events by the prefix or suffix of the key. Supply a builder function and use the Prefix() and Suffix() methods on the filter.\nimageAdded.Observe(images, blob.EventObjectCreated, func(filter *blob.Filter) { filter.Prefix(\u0026quot;/thumbnails\u0026quot;) filter.Suffix(\u0026quot;.jpg\u0026quot;) })  "
},
{
	"uri": "http://microlith-framework.com/resources/strm/processor/",
	"title": "Process Messages from Streams",
	"tags": [],
	"description": "",
	"content": "Processors are Lambda functions that processes messages published to a stream. Each processor may subscribe to multiple streams and is called when messages are published to any of the streams.\nMessages are given to processors in batches. To simplify this, create a Scanner to loop through the batch and process individual messages.\nTo create a process, call the Processor() method on a service builder.\n// Create a processor processor := service.Processor(\u0026quot;the-id\u0026quot;, func(ctx context.Context, evt events.KinesisEvent) error { scanner := NewScanner(evt) for scanner.Next() { var partitionKey, msg string if err := scanner.Scan(\u0026amp;partitionKey, \u0026amp;msg); err != nil { return err } // ... } return nil }) // Create some streams streamOne := service.Stream(\u0026quot;one\u0026quot;) streamTwo := service.Stream(\u0026quot;two\u0026quot;) // Subscribe to the streams processor.Subscribe(streamOne, StartingPositionLatest) processor.Subscribe(streamTwo, StartingPositionTrimHorizon)  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/route53/",
	"title": "Route53",
	"tags": [],
	"description": "",
	"content": " * Almost Zero Configuration\nMicrolith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once complete, the configuration can be reused for all of your Microlith applications.\nYou will need the Domain Name and the Hosted Zone ID to bootstrap your application. For the remainder of the documentation, we will assume you own my-domain.com in hosted zone Z1234567890.\n Domain Name You will need a domain name hosted in Route53. If you have an existing domain, it can be reused. Microlith will not alter the settings of the domain name, only manage a set of subdomain \u0026ldquo;A\u0026rdquo; records for each application.\nRegister a Domain in the AWS Console To register or transfer a domain name from the AWS Console:\n Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Click either the \u0026ldquo;Register Domain\u0026rdquo; or \u0026ldquo;Transfer Domain\u0026rdquo; button Follow the prompts  Email Validation Microlith issues signed SSL certificates for your domain. To validate domain ownership, Microlith uses AWS Certificate Manager\u0026rsquo;s email validation mechanism. You must have a valid contact email able to respond to confirmation emails. There are two options, one if you receive email at the domain and another if you don\u0026rsquo;t.\nAlias If you receive email at \u0026ldquo;my-domain.com\u0026rdquo;, you may receive confirmation emails automatically. By default, Amazon will send confirmation emails to:\n administrator@my-domain.com hostmaster@my-domain.com postmaster@my-domain.com webmaster@my-domain.com admin@my-domain.com  If these email addresses are not valid at your domain name, you can configure an email alias for one or more of them. Otherwise, you must fall back to the WHOIS mechanism.\nWHOIS If you do not receive email at your domain, you must configure your WHOIS information.\nYour domain name must have a valid Domain, Technical, and/or Administrative contact with an email address. You must explicitly disable privacy protection on these contacts so the email addresses are visible in the WHOIS database.\nConfigure WHOIS in the AWS Console  Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Choose the domain name you plan to use for Microlith Click the \u0026ldquo;Edit Contacts\u0026rdquo; button Add email addresses to your Domain, Technical, and/or Administrative contacts Set \u0026ldquo;Privacy Protection\u0026rdquo; to \u0026ldquo;Disable\u0026rdquo; on the contacts Click the \u0026ldquo;Save\u0026rdquo; button  "
},
{
	"uri": "http://microlith-framework.com/resources/stor/",
	"title": "Tables",
	"tags": [],
	"description": "",
	"content": " Microlith supports DynamoDB Tables.\ntype Album struct { Name string Artist string Year int CreatedAt time.Time UpdatedAt time.Time }  suchSweetThunder := Album{ Name: \u0026quot;Such Sweet Thunder\u0026quot;, Artist: \u0026quot;Duke Ellington and His Orchestra\u0026quot;, Year: 1957, CreatedAt: time.Now(), UpdatedAt: time.Now(), } threeSuites := Album{ Name: \u0026quot;Three Suites\u0026quot;, Artist: \u0026quot;Duke Ellington and His Orchestra\u0026quot;, Year: 1959, CreatedAt: time.Now(), UpdatedAt: time.Now(), } aLoveSupreme := Album{ Name: \u0026quot;A Love Supreme\u0026quot;, Artist: \u0026quot;John Coltrane\u0026quot;, Year: 1965, CreatedAt: time.Now(), UpdatedAt: time.Now(), }  Create a Table Tables are created with a hash (\u0026ldquo;partition\u0026rdquo;) key and an optional range (\u0026ldquo;sort\u0026rdquo;) key. The keys must be Attributes. Attributes can be created with the StringAttribute(), NumberAttribute(), and BinaryAttribute() functions.\nThe streaming configuration must also be provided when the table is declared by passing a ChangeType value.\nCreate a table by calling the Table() method on a service builder.\nvar artistKey = stor.StringAttribute(\u0026quot;Artist\u0026quot;) var nameKey = stor.StringAttribute(\u0026quot;Name\u0026quot;) var albums = service.Table(\u0026quot;albums\u0026quot;, artistKey, nameKey, stor.ChangeTypeNewAndOld)  Secondary Indexes DynamoDB supports creating secondary indexes on a table. Microlith supports creating both global and local secondary indexes on a table.\nIndexes project fields from the base table into the index. The projection must be provided at index creation. The constructors for indexes take a ProjectionType as their final argument. For the \u0026ldquo;Include\u0026rdquo; projection type, the names of the attributes to project are taken as varargs.\nGlobal Indexes Like tables, global indexes are created with a hash key and an optional range key. These may be any attributes that are present in the base table.\nTo create a global index, use the GlobalIndex() method. The name must be unique to the table the index is created on.\nvar albumsByYear = table.GlobalIndex(\u0026quot;albums-by-year\u0026quot;, yearKey, nameKey, stor.ProjectionTypeInclude, \u0026quot;Artist\u0026quot;)  Local Indexes Local indexes are created with a non-optional range key. The hash key is automatically the hash key of the base table.\nTo create a local index, use the LocalIndex() method. The name must be a unique to the table the index is created on.\nvar yearKey = stor.NumberAttribute(\u0026quot;Year\u0026quot;) var releaseOrder = table.LocalIndex(\u0026quot;release-order\u0026quot;, yearKey, stor.ProjectionTypeInclude, \u0026quot;Name\u0026quot;)  "
},
{
	"uri": "http://microlith-framework.com/resources/stor/watcher/",
	"title": "Watching for Changes",
	"tags": [],
	"description": "",
	"content": "If change streaming is enabled on a table, changes to the table can be processed using a Watcher Lambda function. Only tables can be watched, not secondary indexes.\nTo create a watcher, call the Watcher() method on a service builder.\n// Create a watcher watcher := service.Watcher(\u0026quot;process-changes\u0026quot;, func(ctx context.Context, evt events.DynamoDBEvent) error { // ... }) // Watch for changes on the table watcher.Watch(table, strm.StartingPositionTrimHorizon)  "
},
{
	"uri": "http://microlith-framework.com/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " Tutorial The tutorial will introduce you to the Microlith API by creating a Hello World application then factoring it into services using Microlith\u0026rsquo;s service-oriented model. By the end of the tutorial, your application will use all of Microlith\u0026rsquo;s service and routing infrastructure.\nThe tutorial focuses on the service model and does not delve into building out service behavior. For an example with non-trivial services, see the blog example.\nThe full source code for the completed tutorial is available here.\n"
},
{
	"uri": "http://microlith-framework.com/resources/rest/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": " APIs follow the AWS API Gateway design, based on Swagger. Define your API by calling the Scope() method on a service or domain builder. Within your scope, use the builder DSL to define your API.\nScopes Scope names are paths, such as \u0026ldquo;/foo\u0026rdquo; or \u0026ldquo;/foo/bar\u0026rdquo;. Scopes can contain path parameters enclosed in curly braces, such as \u0026ldquo;/{foo-id}\u0026rdquo;. Scopes can define nested scopes which are prefixed by their parent scope.\n// Define a scope service.Scope(\u0026quot;/foo\u0026quot;, func(scope *Scope) { // Define a nested scope with a path parameter scope.Scope(\u0026quot;/{foo-id}\u0026quot;, func(scope *Scope) { // ... }) })  Endpoints Endpoints are Lambda functions that handle HTTP requests. They are created with methods named after HTTP methods.\nvar echoEndpoint *Endpoint service.Scope(\u0026quot;/\u0026quot;, func(scope *Scope) { echoEndpoint = scope.Get(\u0026quot;echo\u0026quot;, echoHandler) })  All of the endpoint creation methods take an optional request builder to define query parameters and headers as well as responses.\nservice.Scope(\u0026quot;/\u0026quot;, func(scope *Scope) { scope.Get(\u0026quot;echo\u0026quot;, echoHandler, func(endpoint *Endpoint) { endpoint.QueryParameter(\u0026quot;a-query-param\u0026quot;, false) endpoint.Header(\u0026quot;x-request-header\u0026quot;, false) endpoint.Response(http.StatusOK, func(response *Response) { response.Header(\u0026quot;x-response-header\u0026quot;, false) }) echoEndpoint = endpoint }) })  Within the handler functions, use the RequestBody() and Respond() helpers to parse a JSON request body and respond using JSON. If Respond() is passed an error value, the error message is placed in the \u0026lsquo;X-Microlith-Error\u0026rsquo; header.\n// Handler function func echoHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { var body map[string]interface{} if err := RequestBody(\u0026amp;body); err != nil { return Respond(http.StatusBadRequest, err) } return Respond(http.StatusOK, body) }  Shared Endpoint Properties To define request parameters and responses that are shared, define them on the scope. Endpoints in the scope and all nested scopes will automatically inherit them. Inherited request parameters and responses can be overridden in nested scopes or in individual endpoints.\nmicrolith.Scope(\u0026quot;/foo\u0026quot;, func(scope *Scope) { scope.Header(\u0026quot;x-header\u0026quot;, true) scope.Get(\u0026quot;requires-header\u0026quot;, handler) scope.Put(\u0026quot;does-not-require-header\u0026quot;, handler, func(endpoint *Endpoint) { endpoint.Header(\u0026quot;x-header\u0026quot;, false) }) scope.Scope(\u0026quot;/bar\u0026quot;, func(scope *Scope) { scope.Get(\u0026quot;requires-header\u0026quot;, handler) }) scope.Scope(\u0026quot;/baz\u0026quot;, func(scope *Scope) { scope.Header(\u0026quot;x-header\u0026quot;, false) scope.Get(\u0026quot;does-not-require-header\u0026quot;, handler) }) })  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/bootstrap/",
	"title": "Bootstrap Your Application",
	"tags": [],
	"description": "",
	"content": " Your application has a built-in command to deploy itself into a self-hosted AWS environment. This environments includes a Git repository for your source code and a continuous deployment pipeline for your application with test and production environments. The bootstrap process will then initialize a git repository in your local source tree, create an initial commit, push, and wait for a full build and deploy to go green. Finally, it will healthcheck your deployed application.\nThe process will take several minutes for the initial deploy.\nThe Bootstrap Command For the bootstrap command, you need to provide the DNS settings for both the test and production environments. For each, you need to pass three arguments to the bootstrap command:\n Validation Domain is the domain name whose contacts will be sent confirmation emails. Hosted Zone ID is the Route53 hosted zone your domain name is hosted in. DNS Name is the \u0026ldquo;A\u0026rdquo; record that resolves to your application. These can be your domain name itself or any subdomain of it.  Our validation domain and hosted zone ID for both will the the same: my-domain.com and Z1234567890, respectively. For the DNS names, we will mount the test environment under test.my-domain.com and the production environment under prod.my-domain.com.\nBe sure that your AWS credentials are available to the AWS SDK for Go with no arguments. The configured region will be overridden and the bootstrap process will always deploy to the \u0026ldquo;us-east-1\u0026rdquo; region.\n example.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name prod.my-domain.com  During the bootstrap process, the contact for the \u0026ldquo;my-domain.com\u0026rdquo; domain will receive two confirmation emails for ACM certificates, one for test.my-domain.com and one for prod.my-domain.com. The build pipeline will stall until these email confirmations are completed.\n "
},
{
	"uri": "http://microlith-framework.com/tutorial/globals/",
	"title": "Globals",
	"tags": [],
	"description": "",
	"content": " Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.\nGlobal channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.\nLet\u0026rsquo;s promote the \u0026ldquo;world\u0026rdquo; service to a global service and the \u0026ldquo;requests\u0026rdquo; channel to a global channel.\nPromote the World Service To promote the \u0026ldquo;world\u0026rdquo; service, we need to use the microlith.GlobalService() function.\nfunc init() { // ... Same as before ... microlith.GlobalService(\u0026quot;world\u0026quot;, worldSvc) }  Promote the Requests Channel To promote the \u0026ldquo;requests\u0026rdquo; channel, we need to use the microlith.GlobalChannel() function.\nvar requests = microlith.GlobalChannel(\u0026quot;requests\u0026quot;)  Ship It Now, the \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel are no longer part of the root domain, but shared across all domains. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Promoted 'world' to a global service\u0026quot; git push origin master  Finally, call your endpoints to verify that your application functions as expected.\ncurl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/done/",
	"title": "Done",
	"tags": [],
	"description": "",
	"content": "Congratulations, your application is now bootstrapped! From now on, git push origin master deploys your application:\ngit add . git commit -m \u0026quot;My changes\u0026quot; git push origin master  If you receive a \u0026ldquo;403\u0026rdquo; when trying to push on Mac OS X, the credentials stored in the Keychain have expired. You will need to delete them to push again, as documented in Step 3 here.\n "
},
{
	"uri": "http://microlith-framework.com/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Resources Each service is an AWS::Serverless service composed of resources and asynchronous actions. You add resources and actions via the service builder in your Build() method.\n"
},
{
	"uri": "http://microlith-framework.com/resources/cron/",
	"title": "Schedued Jobs",
	"tags": [],
	"description": "",
	"content": " Jobs are Lambda functions that are invoked on a schedule. The schedule can be a simple time interval or a complex calendar, both expressed using CloudWatch Schedule Expressions.\nSchedule a Job To schedule a job, use the Job() method on a service builder, providing a unique job name, a schedule, and a Lambda function.\nservice.Job(\u0026quot;purge-cache\u0026quot;, \u0026quot;rate(15 minutes)\u0026quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { return json.NewEncoder(os.Stdout).Encode(evt.Details) })  Cron syntax for the schedule is also supported.\nservice.Job(\u0026quot;at-noon\u0026quot;, \u0026quot;cron(0 12 * * ? *)\u0026quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { fmt.Printf(\u0026quot;Should be noon: %s\u0026quot;, evt.Time.Format(\u0026quot;15:04:05\u0026quot;)) })  "
},
{
	"uri": "http://microlith-framework.com/tutorial/subdomains/",
	"title": "Subdomains",
	"tags": [],
	"description": "",
	"content": " Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.\nLet\u0026rsquo;s create a subdomain named \u0026ldquo;sub.domain\u0026rdquo; that returns \u0026ldquo;Hello, subdomain world!\u0026rdquo;. It will have a \u0026ldquo;hello\u0026rdquo; service and use the global \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel. The subdomain\u0026rsquo;s origin will have an endpoint that calls these services and constructs the response.\nCreate the Subdomain First, create a subdomain object. The constructor will take references to the global \u0026ldquo;world\u0026rdquo; service and the \u0026ldquo;requests\u0026rdquo; channel, and will construct a new instance of the \u0026ldquo;hello\u0026rdquo; service. In the builder, we need to register the instance of the \u0026ldquo;hello\u0026rdquo; service with the domain.\n// A Sub is a subdomain type Sub struct { helloSvc *Word worldSvc *Word requests *strm.Stream endpoint *rest.Endpoint client *rest.Client } // NewSub constructs a new subdomain referencing the \u0026quot;world\u0026quot; global service and // the \u0026quot;requests\u0026quot; global channel. func NewSub(world *Word, requests *strm.Stream) *Sub { return \u0026amp;Sub{ helloSvc: NewWord(\u0026quot;hello\u0026quot;, requests), worldSvc: world, requests: requests, } } // Build implements the tld.DomainBuilder interface. func (sub *Sub) Build(domain *tld.Domain) { domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) }  Add an Endpoint Next, we need to add an endpoint on the subdomain\u0026rsquo;s origin. The handler for the endpoint will call the \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo; services and construct a response to return to the user.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... domain.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { sub.endpoint = scope.Get(\u0026quot;hello-subdomain-world\u0026quot;, sub.handler) }) } func (sub *Sub) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := sub.helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := sub.worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloSubdomainWorld := fmt.Sprintf(\u0026quot;%s, subdomain %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloSubdomainWorld) }  Implement a Client Finally, let\u0026rsquo;s add a public client method to the subdomain so we can call it from the root domain. We\u0026rsquo;ll need to create a REST client in the builder using the tld.DomainClient function.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... var err error sub.client, err = tld.DomainClient(domain) if err != nil { log.Panic(err) } } // HelloSubdomainWorld calls the \u0026quot;hello-subdomain-world\u0026quot; endpoint on the // service. On success, it returns the string \u0026quot;Hello, subdomain world!\u0026quot;. // Otherwise, it returns an error. func (sub *Sub) HelloSubdomainWorld(ctx context.Context) (string, error) { resp, err := sub.client.Call(ctx, sub.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Use the Subdomain Mount an instance of this subdomain in the root domain of your application using the microlith.Subdomain() function.\nvar subDomain = NewSub(worldSvc, requests) func init() { // ... Same as before ... microlith.Subdomain(\u0026quot;sub.domain\u0026quot;, subDomain) }  Call the Subdomain The subdomain can be called from the root domain origin, from services in the root domain, or directly via its domain name. Let\u0026rsquo;s add an endpoint to the root domain\u0026rsquo;s origin that calls the subdomain.\nfunc init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { // ... Same as before ... scope.Scope(\u0026quot;/proxy/to/subdomain\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;subdomain\u0026quot;, subHandler) }) }) } func subHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { msg, err := subDomain.HelloSubdomainWorld(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } return rest.Respond(http.StatusOK, msg) }  Ship It Deploy your app:\ngit add . git commit -m \u0026quot;Added a subdomain\u0026quot; git push origin master  Adding a subdomain causes Microlith to issue new SSL certificates. During the deploy, the owner of my-domain.com will receive two confirmation emails for certificates, one for sub.domain.test.my-domain.com and one for sub.domain.prod.my-domain.com. The build pipeline will stall until the confirmations are completed.\n Now you can make requests against the subdomain either directly or via the proxy endpoint:\n# Direct request curl https://sub.domain.prod.my-domain.com/ # Via the proxy endpoint curl https://prod.my-domain.com/proxy/to/subdomain  "
},
{
	"uri": "http://microlith-framework.com/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Examples Example Microlith applications.\n"
},
{
	"uri": "http://microlith-framework.com/resources/inst/",
	"title": "Log Readers",
	"tags": [],
	"description": "",
	"content": " All output from Lambdas is captured as CloudWatch Logs. Readers are Lambda functions that process the resulting log stream.\nCreate a Reader To create a log reader, call the Reader() method on a service builder, providing a unique reader name and a Lambda function to process the log messages.\nonErrors := service.Reader(\u0026quot;on-errors\u0026quot;, func(ctx context.Context, evt events.CloudwatchLogsEvent) error { data, err := evt.AWSLogs.Parse() if err != nil { return err } for _, logEvent := range data.LogEvents { fmt.Printf(\u0026quot;Error found in log group %q: %s\u0026quot;, evt.LogGroup, logEvent.Message) } return nil })  Process Logs Readers can attach to any number of Lambda functions and processes the aggregated logs. Read a function\u0026rsquo;s logs by calling the Read() method on the Reader and passing a Lambda and filter for the logs. The filter must be expressed in CloudWatch Filter and Pattern syntax.\nonErrors.Read(imageAdded, \u0026quot;error\u0026quot;) onErrors.Read(userSignedUp, \u0026quot;error\u0026quot;) onErrors.Read(albumCreated, \u0026quot;error\u0026quot;)  "
},
{
	"uri": "http://microlith-framework.com/cleanup/",
	"title": "Teardown Instructions",
	"tags": [],
	"description": "",
	"content": " The teardown for an application is a straightforward manual procedure in the AWS Console.\nThe bootstrap process creates three main CloudFormation stacks: example-com, example-com-test, and example-com-prod. It also creates multiple nested stacks. The stacks must be deleted in the correct order, and user data in a stack must be manually deleted before a stack can be torn down.\nProcess  On Mac OS X, delete the CodeCommit repository key from Keychain, as described in step 3 here. Empty any buckets in the example-com-test and example-com-prod stacks and any of their nested stacks, Delete the example-com-test and example-com-prod stacks root stacks. Their nested stacks will be torn down automatically. Wait for the example-com-test and example-com-prod stacks to fully delete (i.e., disappear from the CloudFormation console) Empty the bootstrap bucket in the example-com stack Disable termination protection on the example-com stack Delete the example-com stack  If you delete the \u0026ldquo;example-com\u0026rdquo; stack before the \u0026ldquo;-test\u0026rdquo; and \u0026ldquo;-prod\u0026rdquo; stacks have been fully deleted, it will delete the IAM role and you will be unable to tear down the \u0026ldquo;example-com-test\u0026rdquo; and \u0026ldquo;example-com-prod\u0026rdquo; stacks. If this happens, you must manually recreate the deleted \u0026ldquo;DeployRole\u0026rdquo; exactly (including the generated name) to tear down the stacks. Termination protection is enabled on the \u0026ldquo;example-com\u0026rdquo; stack to prevent this.\n "
},
{
	"uri": "http://microlith-framework.com/",
	"title": "Microlith",
	"tags": [],
	"description": "",
	"content": " Microlith Simple Serverless\nfunc init() { microlith.Scope(\u0026quot;/microlith\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;go-serverless\u0026quot;, func(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Go Serverless\u0026quot;) }) }) } func main() { microlith.Main() }  "
},
{
	"uri": "http://microlith-framework.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://microlith-framework.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]