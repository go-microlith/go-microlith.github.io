[
{
	"uri": "http://example.org/examples/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " The complete code from the tutorial is available in the  tutorial.com repository.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/tutorial.com.\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; git clone https://github.com/go-microlith/tutorial.com \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/tutorial.com/.git/\u0026quot; # Build the application go install tutorial.com  Bootstrap Assuming you own the domain name my-domain.com hosted in zone Z1234567890, use:\ntutorial.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name tutorial.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name tutorial.com.prod.my-domain.com  API The APIs for each subdomain are documented below.\nThis application is deployed live at https://tutorial.com.prod.microlith-framework.com\n Root Domain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, world!\u0026rdquo;   GET /proxy/to/subdomain Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    Subdomain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    "
},
{
	"uri": "http://example.org/resources/blob/",
	"title": "Buckets",
	"tags": [],
	"description": "",
	"content": " Buckets Support for S3 Buckets\n"
},
{
	"uri": "http://example.org/resources/blob/create/",
	"title": "Create a Bucket",
	"tags": [],
	"description": "",
	"content": "Create a bucket by calling Bucket() on a service builder.\nimages := service.Bucket(\u0026quot;images\u0026quot;)  "
},
{
	"uri": "http://example.org/resources/cron/create/",
	"title": "Create a Cron Job",
	"tags": [],
	"description": "",
	"content": "Jobs can be scheduled either using CloudWatch events syntax or cron syntax. To use CloudWatch syntax, call ScheduledJob() on a service builder. To use cron syntax, call the CronJob() method.\n// Create a job that runs every 15 minutes service.ScheduledJob(\u0026quot;scheduled-job-id\u0026quot;, \u0026quot;15 minutes\u0026quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { // ... }) // Create a job that runs every day a noon UTC service.CronJob(\u0026quot;cron-job-id\u0026quot;, \u0026quot;0 12 * * ? *\u0026quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { // ... })  "
},
{
	"uri": "http://example.org/resources/inst/create/",
	"title": "Create a Log Reader",
	"tags": [],
	"description": "",
	"content": "Readers can be attached one or more Lambda functions and processes the CloudWatch logs the functions produce. Log messages can be filtered to reduce message volume.\nTo create a log reader, call the Reader() method on a service builder.\n// Create a reader for logs containing the word \u0026quot;error\u0026quot; onErrors := service.Reader(\u0026quot;on-errors\u0026quot;, func(ctx context.Context, evt events.CloudwatchLogsEvent) error { // ... }) // Create some Lambda functions processor := service.Processor(...) observer := service.Observer(...) // Read the Lambda functions' logs onErrors.Read(processor, \u0026quot;processor error\u0026quot;) onErrors.Read(observer, \u0026quot;observer error\u0026quot;)  "
},
{
	"uri": "http://example.org/resources/strm/create/",
	"title": "Create a Stream",
	"tags": [],
	"description": "",
	"content": "Create a stream by calling Stream() on a service builder:\nuserSignups := service.Stream(\u0026quot;user-signups\u0026quot;)  "
},
{
	"uri": "http://example.org/resources/stor/create/",
	"title": "Create a Table",
	"tags": [],
	"description": "",
	"content": "Create a table by calling the Table() method on a service builder.\n// Create a table var hashKey = StringAttribute(\u0026quot;hash-key\u0026quot;) var rangeKey = StringAttribute(\u0026quot;range-key\u0026quot;) var table = service.Table(\u0026quot;the-id\u0026quot;, hashKey, rangeKey, ChangeTypeNewAndOld)  To create secondary indexes on a table, use the GlobalIndex() and LocalIndex() methods.\n// Create a Global Secondary Index var gsiHashKey = StringAttribute(\u0026quot;gsi-hash-key\u0026quot;) var gsiRangeKey = StringAttribute(\u0026quot;gsi-range-key\u0026quot;) var gsi = table.GlobalIndex(\u0026quot;gsi\u0026quot;, gsiHashKey, gsiRangeKey, ProjectionTypeAll) // Create a Local Secondary Index var lsiRangeKey = StringAttribute(\u0026quot;lsi-range-key\u0026quot;) var lsi = table.LocalIndex(\u0026quot;lsi\u0026quot;, lsiRangeKey, ProjectionTypeInclude, \u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;)  "
},
{
	"uri": "http://example.org/resources/rest/define/",
	"title": "Define an API",
	"tags": [],
	"description": "",
	"content": " APIs follow the AWS API Gateway design, based on Swagger. Define your API by calling the Scope() method on a service or domain builder. Within your scope, use the builder DSL to define your API.\nScopes Scope names are paths, such as \u0026ldquo;/foo\u0026rdquo; or \u0026ldquo;/foo/bar\u0026rdquo;. Scopes can contain path parameters enclosed in curly braces, such as \u0026ldquo;/{foo-id}\u0026rdquo;. Scopes can define nested scopes which are prefixed by their parent scope.\n// Define a scope service.Scope(\u0026quot;/foo\u0026quot;, func(scope *Scope) { // Define a nested scope with a path parameter scope.Scope(\u0026quot;/{foo-id}\u0026quot;, func(scope *Scope) { // ... }) })  Endpoints Endpoints are Lambda functions that handle HTTP requests. They are created with methods named after HTTP methods.\nvar echoEndpoint *Endpoint service.Scope(\u0026quot;/\u0026quot;, func(scope *Scope) { echoEndpoint = scope.Get(\u0026quot;echo\u0026quot;, echoHandler) })  All of the endpoint creation methods take an optional request builder to define query parameters and headers as well as responses.\nservice.Scope(\u0026quot;/\u0026quot;, func(scope *Scope) { scope.Get(\u0026quot;echo\u0026quot;, echoHandler, func(endpoint *Endpoint) { endpoint.QueryParameter(\u0026quot;a-query-param\u0026quot;, false) endpoint.Header(\u0026quot;x-request-header\u0026quot;, false) endpoint.Response(http.StatusOK, func(response *Response) { response.Header(\u0026quot;x-response-header\u0026quot;, false) }) echoEndpoint = endpoint }) })  Within the handler functions, use the RequestBody() and Respond() helpers to parse a JSON request body and respond using JSON. If Respond() is passed an error value, the error message is placed in the \u0026lsquo;X-Microlith-Error\u0026rsquo; header.\n// Handler function func echoHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { var body map[string]interface{} if err := RequestBody(\u0026amp;body); err != nil { return Respond(http.StatusBadRequest, err) } return Respond(http.StatusOK, body) }  Shared Endpoint Properties To define request parameters and responses that are shared, define them on the scope. Endpoints in the scope and all nested scopes will automatically inherit them. Inherited request parameters and responses can be overridden in nested scopes or in individual endpoints.\nmicrolith.Scope(\u0026quot;/foo\u0026quot;, func(scope *Scope) { scope.Header(\u0026quot;x-header\u0026quot;, true) scope.Get(\u0026quot;requires-header\u0026quot;, handler) scope.Put(\u0026quot;does-not-require-header\u0026quot;, handler, func(endpoint *Endpoint) { endpoint.Header(\u0026quot;x-header\u0026quot;, false) }) scope.Scope(\u0026quot;/bar\u0026quot;, func(scope *Scope) { scope.Get(\u0026quot;requires-header\u0026quot;, handler) }) scope.Scope(\u0026quot;/baz\u0026quot;, func(scope *Scope) { scope.Header(\u0026quot;x-header\u0026quot;, false) scope.Get(\u0026quot;does-not-require-header\u0026quot;, handler) }) })  "
},
{
	"uri": "http://example.org/bootstrap/go_get/",
	"title": "Get Microlith",
	"tags": [],
	"description": "",
	"content": "Microlith is a standard Go library. Just use \u0026ldquo;go get\u0026rdquo;:\ngo get gopkg.in/microlith.v0  Now you\u0026rsquo;re ready to create your first application.\n"
},
{
	"uri": "http://example.org/architecture/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Business logic for an application is factored into Services. A Service is a REST API, a set of resources, and a set of asynchronous actions.\nServerless Services follow an AWS::Serverless model, containing resources such as Buckets, Tables, and Streams along with Lambda functions to asynchronously react to events on those resources. All external access to the resources goes through endpoints on a REST API.\nScope All resources in the service are available to all Lambdas in the service, but services cannot access resources outside of the ones they declare nor other services.\nServices are not directly routable from the internet. Services must live in a container that makes calls on them.\n"
},
{
	"uri": "http://example.org/tutorial/root/",
	"title": "The Root Domain",
	"tags": [],
	"description": "",
	"content": " The root domain is the starting point for a Microlith application. It has a specialized API exposed via the top-level \u0026ldquo;microlith\u0026rdquo; package.\nWe will start by adding a \u0026ldquo;Hello, world!\u0026rdquo; endpoint to our application.\nThe Origin You add endpoints by defining an API with the microlith.Scope() function.\nYou must pass a unique name and a handler function for each defined endpoint. This function must match the signature of an API Gateway Lambda Function.\nIn ${GOPATH}/src/example.com/root.go:\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/aws/aws-lambda-go/events\u0026quot; microlith \u0026quot;gopkg.in/microlith.v0\u0026quot; \u0026quot;gopkg.in/microlith.v0/sam/tld/rest\u0026quot; ) func init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;hello-world\u0026quot;, handler) }) } func handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Hello, world!\u0026quot;) }  Ship It Deploy your app:\ngit add . git commit -m \u0026quot;Added my first endpoint\u0026quot; git push origin master  Once your application has deployed, you can make requests against your endpoint:\ncurl https://prod.my-domain.com/  You should receive a response of \u0026ldquo;Hello, world!\u0026rdquo;\nFreshly deployed Lambdas perform a cold start when the first request is received. When manual testing, you application may return a 500 Internal Server Error on the first few requests after deployment until the Lambdas warm up. If it does, wait a few seconds and retry the request a couple of times until it returns the expected response.\n "
},
{
	"uri": "http://example.org/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction Microlith is a simple-to-use AWS::Serverless framework written in Go.\nThe documentation will take you through bootstrapping your first application, explain Microlith\u0026rsquo;s architecture, and then take you through a guided tutorial of using Microlith.\n"
},
{
	"uri": "http://example.org/examples/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": " A blogging application with social features is available in the  blog.com repository.\nIt provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (\u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, etc.) on both posts and comments.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/blog.com:\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/blog.com\u0026quot; git clone https://github.com/go-microlith/blog.com \u0026quot;${GOPATH}/src/blog.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/blog.com/.git/\u0026quot; # Build the application go install blog.com  Bootstrap blog.com bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name blog.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name blog.com.prod.my-domain.com  API This application is deployed live to https://blog.com.prod.microlith-framework.com/\n Root Domain    Method URL Example Request Body Description     GET /posts N/A Get all blog posts with comments and reactions   POST /posts {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The post body\u0026rdquo;} Create a blog post   GET /posts/{post-id} N/A Get a specific blog post   PUT /posts/{post-id} {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;Updated body\u0026rdquo;} Update the contents of a blog post   DELETE /posts/{post-id} N/A Delete a specific blog post   POST /posts/{post-id}/like N/A React to a blog post with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/love N/A React to a blog post with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/haha N/A React to a blog post with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/wow N/A React to a blog post with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/sad N/A React to a blog post with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/angry N/A React to a blog post with a \u0026ldquo;Angry\u0026rdquo;   POST /posts/{post-id}/comments {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The comment\u0026rdquo;} Comment on a blog post   POST /posts/{post-id}/comments/{comment-id}/like N/A React to a comment with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/love N/A React to a comment with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/haha N/A React to a comment with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/wow N/A React to a comment with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/sad N/A React to a comment with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/angry N/A React to a comment with a \u0026ldquo;Angry\u0026rdquo;    Implementation This application is implemented with a single service in the root domain, two global services, and a global channel.\nThe posts service in the root domain provides CRUD operations on blog posts. It is backed by a single DynamoDB table to store the posts.\nThe comments global service provides the ability to comment on an object and to fetch all of the comments on an object. It is backed by a single DynamoDB table to store the comments. The table has a global secondary index to fetch time-ordered comments on a single object.\nThe reactions global service provides the ability to react to an object and to fetch a summary of the reactions to an object. It is backed by a single DynamoDB table to store the reactions. It lives in the blog.com/reactions package.\nThe object-deleted global channel contains events with the IDs of objects that were deleted. The posts service watches its DynamoDB table for deletes and emits an event on the channel when one is detected. The comments and reactions service processes the channel and purges any comments on and reactions to the deleted objects. The comments service also watches its DynamoDB table for deletes and emits events on the channel so that reactions to comments are also deleted.\nThe origin provides a complete API for the user. The list-posts endpoint fetches the posts along with their comments and reactions to return them to the user. The rest of the endpoints are proxies to service endpoints to interact with the returned posts.\n"
},
{
	"uri": "http://example.org/resources/rest/call/",
	"title": "Call an API",
	"tags": [],
	"description": "",
	"content": "Call APIs by creating a Client and calling the Call() method. This takes the endpoint to call and an optional request body for non HEAD and GET requests. Call() can be passed an optional request builder to set the path and query parameters and request headers. The Call() method returns a standard http.Response.\nrequestBody := map[string]interface{}{\u0026quot;Foo\u0026quot;: \u0026quot;bar\u0026quot;} responseBody := map[string]interface{}{} // Construct a new client var client = NewClient(\u0026quot;http://localhost:8080/\u0026quot;) // Call an endpoint resp, err := client.Call(echoEndpoint, requestBody, func(request *Request) { request.QueryParameter(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;) request.Header(\u0026quot;x-foo\u0026quot;, \u0026quot;bar\u0026quot;) }) if err != nil { log.Panic(err) }  Use the ResponseBody() and ErrorResponse() helpers to parse the response. ResponseBody() parses the response body as JSON. ErrorResponse() creates an error out of the \u0026lsquo;X-Microlith-Error\u0026rsquo; header. If the second argument to ErrorResponse() is a non-nil error, the response body is deserialized into it.\nswitch resp.StatusCode { case http.StatusOK: if err := ResponseBody(resp, \u0026amp;responseBody); err != nil { log.Panic(err) } default: err := ErrorResponse(resp, nil) log.Panic(err) }  "
},
{
	"uri": "http://example.org/architecture/domains/",
	"title": "Domains",
	"tags": [],
	"description": "",
	"content": " Services are grouped into a Domain. A Domain is a REST API, a set of services, and set of channels.\nRouting Domains route using REST. The API, called the Origin, handles all external traffic. It receives requests, makes calls on the services to collect state and perform business logic, and then constructs a response to the user.\n"
},
{
	"uri": "http://example.org/resources/strm/publisher/",
	"title": "Publishing to Streams",
	"tags": [],
	"description": "",
	"content": "To publish to a stream, create a Publisher object and Publish() messages. The publisher automatically encodes the messages to JSON and batches messages before sending. Be sure to Flush() your publisher to ensure the final batch is sent.\n// Create a publisher var publisher = NewPublisher(userSignups) func someHandler(ctx context.Context) error { // Be sure to Flush() the publisher defer publisher.Flush(ctx) // Write messages to the stream if err := publisher.Publish(ctx, \u0026quot;partition-one\u0026quot;, \u0026quot;value-one\u0026quot;); err != nil { return err } return publisher.Publish(ctx, \u0026quot;partition-two\u0026quot;, \u0026quot;value-one\u0026quot;, \u0026quot;value-two\u0026quot;) }  Streams are created with an AWS-assigned stream name. This name is available at runtime via the StreamName() function.\nclient := kinesis.New(session.New()) streamName := StreamName(userSignups) client.PutRecords(\u0026amp;kinesis.PutRecordsInput{ StreamName: aws.String(streamName), // ... })  "
},
{
	"uri": "http://example.org/tutorial/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Services implement the business logic of your Microlith application. At the code level, a service is an object which implements the tld.ServiceBuilder interface.\nLet\u0026rsquo;s refactor our domain into a pair of services: a \u0026ldquo;hello\u0026rdquo; and a \u0026ldquo;world\u0026rdquo; service. Then we\u0026rsquo;ll refactor our origin endpoint to call those services to build a response.\nCreate a Service We will create a \u0026ldquo;word\u0026rdquo; service that returns a fixed word. The word service will have one endpoint that responds with the word as JSON.\nTo create the service, create an service object in ${GOPATH}/src/example.com/word.go:\npackage main import ( \u0026quot;gopkg.in/microlith.v0/sam/tld\u0026quot; \u0026quot;gopkg.in/microlith.v0/sam/tld/rest\u0026quot; ) // Word is a service that returns a fixed word type Word struct { word string client *rest.Client endpoint *rest.Endpoint } // NewWord constructs an instance of the \u0026quot;word\u0026quot; service returning the word. func NewWord(word string) *Word { return \u0026amp;Word{ word: word, } } // Build implements the tld.ServiceBuilder interface. func (word *Word) Build(service *tld.Service) { // TODO }  Add An Endpoint To add an endpoint, use the Scope() method on the service builder. We will capture the endpoint in an instance variable so we can use it in the next step.\nfunc (word *Word) Build(service *tld.Service) { service.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { word.endpoint = scope.Get(\u0026quot;word\u0026quot;, word.handler) }) } func (word *Word) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, word.word) }  Implement a Client To implement a client, add public methods to your service.\nTo make calls against your service, use the tld.ServiceClient() function create a rest.Client in your service builder. Use the client to Call() endpoints.\nfunc (word *Word) Build(service *tld.Service) { // ... Same as before ... var err error word.client, err = tld.ServiceClient(service) if err != nil { log.Panic(err) } } // Word calls the \u0026quot;word\u0026quot; endpoint. On success, it returns the word. Otherwise, // it returns an error. func (word *Word) Word(ctx context.Context) (string, error) { resp, err := word.client.Call(ctx, word.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Use the Service Now that we have a \u0026ldquo;word\u0026rdquo; service, we can use it in our origin to factor out our business logic.\nWe will create two instances of the service returning \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo;. Then, we will call those from our origin to construct our response.\nRegister the Services First, you must create and register the services with your domain using the microlith.Service() function.\nIn root.go:\nvar ( helloSvc = NewWord(\u0026quot;hello\u0026quot;) worldSvc = NewWord(\u0026quot;world\u0026quot;) ) func init() { // ... Same as before ... microlith.Service(\u0026quot;hello\u0026quot;, helloSvc) microlith.Service(\u0026quot;world\u0026quot;, worldSvc) }  Call the Services Next, use your the client methods on your service object to call the services. Construct a response to the user from the responses to the service calls.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloWorld := fmt.Sprintf(\u0026quot;%s, %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloWorld) }  Ship It You should be ready to deploy.\ngit add . git commit -m \u0026quot;Factored into services\u0026quot; git push origin master  Once deployed, you can make requests against your domain. You should see the same response as before.\ncurl -v https://prod.my-domain.com/  You might notice that this deploy takes longer than the last deploy. This is because Microlith uses safe Lambda deploys. By default, the test environment transitions traffic using the \u0026ldquo;AllAtOnce\u0026rdquo; configuration and the production environment uses the \u0026ldquo;Canary10Percent5Minutes\u0026rdquo; configuration. These are both configurable via the bootstrap process.\n "
},
{
	"uri": "http://example.org/resources/strm/",
	"title": "Streams",
	"tags": [],
	"description": "",
	"content": " Streams Support for Kinesis Streams\n"
},
{
	"uri": "http://example.org/resources/blob/manipulator/",
	"title": "Working with Buckets",
	"tags": [],
	"description": "",
	"content": "Objects are added, updated, and removed from a bucket using a Manipulator.\n// Create a manipulator mnip := NewManipulator(images) // Put an object into the bucket body, err := NewBufferString(\u0026quot;the-body\u0026quot;) if err != nil { log.Panic(err) } defer body.Close() if err := mnip.Put(ctx, \u0026quot;/the/key\u0026quot;, body); err != nil { log.Panic(err) } // Get the object from the bucket contents, err := mnip.Get(ctx, \u0026quot;/the/key\u0026quot;) if err != nil { log.Panic(err) } io.Copy(os.Stdout, contents) // Delete the object from the bucket if err := mnip.Delete(ctx, \u0026quot;/the/key\u0026quot;); err != nil { log.Panic(err) }  Buckets are created with an AWS-assigned bucket name. This name is available at runtime via the BucketName() function.\nclient := s3.New(session.New()) bucketName := BucketName(bucket) client.PutObject(\u0026amp;s3.PutObjectInput{ Bucket: aws.String(bucketName), // ... })  "
},
{
	"uri": "http://example.org/resources/stor/mutator/",
	"title": "Working with Tables",
	"tags": [],
	"description": "",
	"content": " To interact with a table, create a Mutator. A Mutator is a client for a DynamoDB table.\n// Create the mutator mutator := NewMutator(table)  Mutators supports queries, scans, and CRUD operations. Batch operations are supported using separate GetBatch() and WriteBatch() functions.\nFor indexes, create a Querier. This works identically to a Mutator but is limited to the Query() and Scan() operations only.\nAll operations support optional builders to refine the operations.\nCRUD Operations Mutators support Put, Get, Update, and Delete operations on individual items.\nPut inserts or overwrites a value in the table.\nitem := map[string]interface{}{ \u0026quot;hash-key\u0026quot;: \u0026quot;hash-key-value\u0026quot;, \u0026quot;range-key\u0026quot;: \u0026quot;range-key-value\u0026quot;, \u0026quot;Foo\u0026quot;: \u0026quot;bar\u0026quot;, } if err := mutator.Put(ctx, item); err != nil { log.Panic(err) }  Get fetches a single item from the table. You must provide a value to deserialize the fetched item, if found.\nkey := map[string]interface{}{ \u0026quot;hash-key\u0026quot;: \u0026quot;hash-key-value\u0026quot;, \u0026quot;range-key\u0026quot;: \u0026quot;range-key-value\u0026quot;, } var value map[string]interface{} found, err := mutator.Get(ctx, key, \u0026amp;value) if err != nil { log.Panic(err) }  Update mutates an item in-place in the table. This takes an update expression using the DynamoDB expression syntax.\nif err := mutator.Update(ctx, key, func(update *Update) { update.Update( expression. Set(expression.Name(\u0026quot;Foo\u0026quot;), expression.Value(\u0026quot;asdf\u0026quot;)). Add(expression.Name(\u0026quot;Bar\u0026quot;), expression.Value(\u0026quot;quux\u0026quot;)), ) }); err != nil { log.Panic(err) }  Delete removes an item from the table.\nif err := mutator.DeleteItem(ctx, key); err != nil { log.Panic(err) }  Query Operations The Query and Scan operations operate a page of results at a time. They return a Result object to process the items in the results.\n// Query the first page of results from the table result, err := mutator.Query(ctx, func(query *Query) { query.KeyCondition( expression.Name(\u0026quot;Foo\u0026quot;).Equal(expression.Value(\u0026quot;bar\u0026quot;)), ) }) if err != nil { log.Panic(err) }  To fetch and process all of the pages, the Result object contains the last evaluated key\n// Scan the entire table into an array var results []map[string]interface{} result, err := mutator.Scan(ctx) for { if err != nil { log.Panic(err) } for result.Next() { var result map[string]interface{} if err := result.Scan(result); err != nil { log.Panic(err) } results = append(results, result) } if result.LastEvaluatedKey() == nil { break } result, err = mutator.Scan(ctx, func(scan *Scan) { scan.ExclusiveStartKey(result.LastEvaluatedKey()) }) }  Batch Operations Batch operations are supported via the top-level GetBatch() and WriteBatch() functions.\nGetBatch retrieves multiple items from multiple tables at once. The result returned provides Scanners for the retrieved items. If not all gets are processed, the result provides a mechanism to reprocess them.\n// Keys to fetch keyOne := map[string]interface{}{ \u0026quot;hash-key\u0026quot;: \u0026quot;hash-key-value\u0026quot;, \u0026quot;range-key\u0026quot;: \u0026quot;range-key-value\u0026quot;, } keyTwo := map[string]interface{}{\u0026quot;hash-key\u0026quot;: \u0026quot;foo\u0026quot;}, keyThree := map[string]interface{}{\u0026quot;hash-key\u0026quot;: \u0026quot;bar\u0026quot;}, // Fetch one value from tableOne and two values from tableTwo. result, err := GetBatch(ctx, func(batch *BatchGet) { batch.Table(tableOne, func(get *BatchGetGet) { get.Keys(keyOne) }) batch.Table(tableTwo, func(get *BatchGetGet) { get.Keys(keyTwo, keyThree) }) }) for { if err != nil { log.Panic(err) } // Scan the results from tableOne scanner := result.Table(tableOne) for scanner.Next() { var value map[string]interface{} if err := scanner.Scan(value); err != nil { log.Panic(err) } // ... } // Scan the results from tableTwo scanner = result.Table(tableTwo) for scanner.Next() { var value map[string]interface{} if err := scanner.Scan(value); err != nil { log.Panic(err) } // ... } // See if there are unprocessed items if !result.More() { break } // Continue the batch operation result, err = result.Continue(ctx) }  WriteBatch performs multiple put and/or delete operations at once. Like GetBatch, WriteBatch may return only a partial result. The result object returned provides a mechanism to reprocess unprocessed operations.\n// Value to put value := map[string]interface{}{ \u0026quot;hash-key\u0026quot;: \u0026quot;hash-key-value\u0026quot;, \u0026quot;range-key\u0026quot;: \u0026quot;range-key-value\u0026quot;, \u0026quot;Foo\u0026quot;: \u0026quot;bar\u0026quot;, } // Keys to delete keyOne := map[string]interface{}{\u0026quot;hash-key\u0026quot;: \u0026quot;value-one\u0026quot;} keyTwo := map[string]interface{}{\u0026quot;hash-key\u0026quot;: \u0026quot;value-two\u0026quot;} // Write the value to tableOne and delete the keys from tableTwo result, err := WriteBatch(ctx, func(batch *BatchWrite) { batch.Put(tableOne, value) batch.Delete(tableTwo, keyOne, keyTwo) }) if err != nil { log.Panic(err) } // Reprocess any unprocessed operations for result.More() { result, err = result.Continue(ctx) if err != nil { log.Panic(err) } }  "
},
{
	"uri": "http://example.org/bootstrap/create/",
	"title": "Your First Application",
	"tags": [],
	"description": "",
	"content": " Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com.\nCreate an Application To create an application, create an executable in ${GOPATH}/src/example.com/main.go and call microlith.Main():\npackage main import ( microlith \u0026quot;gopkg.in/microlith.v0\u0026quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, \u0026ldquo;example.com\u0026rdquo;.\nThe import path of the source code is also significant to Microlith. By default, the main executable must live in the root of your repo at the root of your Go workspace\u0026rsquo;s source tree. In this case, \u0026ldquo;${GOPATH}/src/example.com\u0026rdquo;\nBuild Now, build your application:\ngo install example.com  Your application is now ready to be bootstrapped. Before you can do that, you need to set up Route53.\n"
},
{
	"uri": "http://example.org/bootstrap/",
	"title": "Bootstrap",
	"tags": [],
	"description": "",
	"content": " Bootstrap Bootstrap will step you through getting your first Microlith application set up via the automated bootstrap process. By the end of the bootstrap, you will be able to \u0026ldquo;push to prod\u0026rdquo;:\n# Deploy your application git add . git commit -m \u0026quot;My changes\u0026quot; git push origin master # Use your test and production environments curl -v https://test.my-domain.com/ curl -v https://prod.my-domain.com/  "
},
{
	"uri": "http://example.org/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": " Architecture Microlith is built on a service-oriented model called the Domain model. In the Domain model, Services are units of business logic. The model provides abstractions to group services, route external traffic to them, and to communicate internally between them.\nThere are five core concepts to Microlith\u0026rsquo;s architecture:\n Services contain business logic Domains group and route to services Channels communicate between services The Application groups and routes to domains. Globals are shared between domains  "
},
{
	"uri": "http://example.org/architecture/channels/",
	"title": "Channels",
	"tags": [],
	"description": "",
	"content": "Services need to communicate, but cannot call endpoints on each other. To communicate between services, Microlith provides broadcast channels.\nAny service can publish events onto channels it has references to. When a service publishes an event on a channel, all subscribed processors in all services receive that event.\n"
},
{
	"uri": "http://example.org/tutorial/channels/",
	"title": "Channels",
	"tags": [],
	"description": "",
	"content": " Channels are created by calling either the microlith.Channel() function to create a channel in the root domain, or by calling the microlith.Channel() method on a domain builder to create a channel in a subdomain. The returned reference can then be passed to a service so the service can interact with the channel.\nLet\u0026rsquo;s create a channel that logs an event when a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint in the Origin.\nCreate a Channel First, create the channel and an event type in the origin.\nIn root.go:\nvar ( requests = microlith.Channel(\u0026quot;requests\u0026quot;) // ... Same as before ... ) type Request struct { At time.Time }  Update the Word Service Next, we need to pass the channel to the services that will use it and start processing events sent over the channel.\nUpdate the Constructor First, update the constructor for the word service so that it takes the channel as an argument.\nIn word.go:\ntype Word struct { // ... Same as before ... requests *strm.Stream } // NewWord constructs an instance of the \u0026quot;word\u0026quot; service that returns the word // and processes the requests channel. func NewWord(word string, requests *strm.Stream) *Word { return \u0026amp;Word{ word: word, requests: requests, } }  Process Events Next, process events on the channel by creating a strm.Processor in the builder. Implement a Kinesis Lambda method to handle the events. Use the Subscribe() method to subscribe to the channel.\nfunc (word *Word) Build(service *tld.Service) { // ... Same as before ... processor := service.Processor(\u0026quot;requests\u0026quot;, word.processRequests) processor.Process(word.requests, strm.StartingPositionTrimHorizon) } func (word *Word) processRequests(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { partitionKey := \u0026quot;\u0026quot; request := new(Request) if err := scanner.Scan(\u0026amp;partitionKey, request); err != nil { return err } log.Printf(\u0026quot;Request made at %s\u0026quot;, request.At.Format(time.RFC3339Nano)) } return nil }  Emit Events Now that the services are updated to subscribe to the channel, we need to provide the channel to the services and start publishing events.\nUse the Updated Constructor Use the new constructors to pass the channel to the services.\nIn root.go:\nvar ( requests = microlith.Channel(\u0026quot;requests\u0026quot;) helloSvc = NewWord(\u0026quot;hello\u0026quot;, requests) worldSvc = NewWord(\u0026quot;world\u0026quot;, requests) )  Publish Events Finally, publish an event to the channel on every request. Be sure to always Flush() publishers to ensure that any batched messages are sent.\nvar publisher = strm.NewPublisher(requests) func handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { defer publisher.Flush(ctx) if err := publisher.Publish(ctx, \u0026quot;partition-key\u0026quot;, \u0026amp;Request{At: time.Now()}); err != nil { return rest.Respond(http.StatusInternalServerError, err) } // ... Same as before ... }  Ship It Now both services will process an event every time a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Added a channel\u0026quot; git push origin master  Make a request against your application and the processors will soon emit a message to their CloudWatch logs.\ncurl -v https://prod.my-domain.com/  "
},
{
	"uri": "http://example.org/resources/blob/observer/",
	"title": "Observing Changes",
	"tags": [],
	"description": "",
	"content": "Observers are Lambda functions that observe buckets and are executed when their contents change. Each observer may subscribe to multiple buckets and multiple events per bucket. Additionally, events can be filtered on either the prefix or suffix of the key.\nObservers cannot access buckets. This is due to a circular dependency in CloudFormation. If an observer needs to access buckets, a work around is to publish all events to a Stream and create a processor to perform the action.\n Create an observer by calling the Observer() function on a service builder.\n// Create an observer to watch bucket changes observer := service.Observer(\u0026quot;watch-all-the-things\u0026quot;, func(ctx context.Context, evt events.S3Event) error { // ... }) // Create some buckets bucketOne := service.Bucket(\u0026quot;one\u0026quot;) bucketTwo := service.Bucket(\u0026quot;two\u0026quot;) // Observe when an object is created in bucket \u0026quot;one\u0026quot; with a prefix of \u0026quot;/foo\u0026quot; // or \u0026quot;/bar\u0026quot; and a suffix of \u0026quot;.gz\u0026quot;. observer.Bucket(bucketOne, EventObjectCreated, func(filter *Filter) { filter.Prefix(\u0026quot;/foo\u0026quot;, \u0026quot;/bar\u0026quot;) filter.Suffix(\u0026quot;.gz\u0026quot;) }) // Observe when any object is deleted from bucket \u0026quot;one\u0026quot; observer.Bucket(bucketOne, EventObjectDeleted) // Observe when any object is created in bucket \u0026quot;two\u0026quot; with a PUT request. observer.Bucket(bucketTwo, EventObjectCreatedPut)  "
},
{
	"uri": "http://example.org/resources/strm/processor/",
	"title": "Process Messages from Streams",
	"tags": [],
	"description": "",
	"content": "Processors are Lambda functions that processes messages published to a stream. Each processor may subscribe to multiple streams and is called when messages are published to any of the streams.\nMessages are given to processors in batches. To simplify this, create a Scanner to loop through the batch and process individual messages.\nTo create a process, call the Processor() method on a service builder.\n// Create a processor processor := service.Processor(\u0026quot;the-id\u0026quot;, func(ctx context.Context, evt events.KinesisEvent) error { scanner := NewScanner(evt) for scanner.Next() { var partitionKey, msg string if err := scanner.Scan(\u0026amp;partitionKey, \u0026amp;msg); err != nil { return err } // ... } return nil }) // Create some streams streamOne := service.Stream(\u0026quot;one\u0026quot;) streamTwo := service.Stream(\u0026quot;two\u0026quot;) // Subscribe to the streams processor.Subscribe(streamOne, StartingPositionLatest) processor.Subscribe(streamTwo, StartingPositionTrimHorizon)  "
},
{
	"uri": "http://example.org/bootstrap/route53/",
	"title": "Route53",
	"tags": [],
	"description": "",
	"content": " Microlith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once set up, a domain name can be reused for multiple Microlith applications.\nYou will need the Domain Name and the Hosted Zone ID to bootstrap your application. For the remainder of the documentation, we will assume you own my-domain.com in hosted zone Z1234567890.\n Domain Name You will need a domain name hosted in Route53. If you have an existing domain, it can be reused. Microlith will not alter the settings of the domain name, only manage a set of subdomain \u0026ldquo;A\u0026rdquo; records for each application.\nRegister a Domain in the AWS Console To register or transfer a domain name from the AWS Console:\n Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Click either the \u0026ldquo;Register Domain\u0026rdquo; or \u0026ldquo;Transfer Domain\u0026rdquo; button Follow the prompts  Email Validation Microlith issues SSL certificates against your domain via AWS Certificate Manager using email validation. You must have a valid contact email able to respond to confirmation emails. There are two options, one if you have email at the domain and another if you don\u0026rsquo;t.\nEmail Alias (Recommended) If you receive email at \u0026ldquo;my-domain.com\u0026rdquo;, you may receive confirmation emails automatically. By default, Amazon will send confirmation emails to:\n administrator@my-domain.com hostmaster@my-domain.com postmaster@my-domain.com webmaster@my-domain.com admin@my-domain.com  If these email addresses are not valid at your domain name, configure an email alias.\nWHOIS If you do not receive email at your domain, you must configure your WHOIS information.\nYour domain name must have a valid Domain, Technical, and/or Administrative contact with an email address. You must explicitly disable privacy protection on these contacts so the email addresses are visible in the WHOIS database.\nConfigure WHOIS in the AWS Console  Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Choose the domain name you wish to use for Microlith Click the \u0026ldquo;Edit Contacts\u0026rdquo; button Add email addresses to your Domain, Technical, and/or Administrative contacts Set \u0026ldquo;Privacy Protection\u0026rdquo; to \u0026ldquo;Disable\u0026rdquo; on the contacts Click the \u0026ldquo;Save\u0026rdquo; button  "
},
{
	"uri": "http://example.org/resources/stor/",
	"title": "Tables",
	"tags": [],
	"description": "",
	"content": " Tables Support for DynamoDB Tables\n"
},
{
	"uri": "http://example.org/resources/stor/watcher/",
	"title": "Watching for Changes",
	"tags": [],
	"description": "",
	"content": "If change streaming is enabled on a table, changes to the table can be processed using a Watcher Lambda function. Only tables can be watched, not secondary indexes.\nTo create a watcher, call the Watcher() method on a service builder.\n// Create a watcher watcher := service.Watcher(\u0026quot;process-changes\u0026quot;, func(ctx context.Context, evt events.DynamoDBEvent) error { // ... }) // Watch for changes on the table watcher.Watch(table, strm.StartingPositionTrimHorizon)  "
},
{
	"uri": "http://example.org/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " Tutorial The tutorial will get you started building Microlith applications. The full source code for the completed tutorial is available here.\nThe tutorial will start by creating a Hello World. You will then factor it out into services using Microlith\u0026rsquo;s service-oriented model. By the end of the tutorial, you will have a simple application that uses all of Microlith\u0026rsquo;s service and routing infrastructure.\n"
},
{
	"uri": "http://example.org/resources/rest/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": " REST APIs Define var endpoint *rest.Endpoint service.Scope(\u0026quot;/hello\u0026quot;, func(scope *rest.Scope) { endpoint = scope.Get(\u0026quot;world\u0026quot;, func(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Hello, world!\u0026quot;) }) }) client := tld.ServiceClient(service)  Call resp, err := client.Call(endpoint, nil) if err != nil { // ... } switch resp.StatusCode { case http.StatusOK: var body map[string]interface{} return body, rest.ResponseBody(resp, \u0026amp;body) default: return nil, rest.ErrorResponse(resp, nil) }  "
},
{
	"uri": "http://example.org/architecture/application/",
	"title": "Application",
	"tags": [],
	"description": "",
	"content": " An Application is the top-level container in a Microlith app. An application is a root domain, a set of named subdomains, and a set of global services and channels.\nRouting An Application routes using DNS. The root domain is mounted under the top-level DNS name specified in the bootstrap process. All subdomains are mounted relative to the root domain.\n"
},
{
	"uri": "http://example.org/bootstrap/bootstrap/",
	"title": "Bootstrap Your Application",
	"tags": [],
	"description": "",
	"content": " The bootstrap process will host for your application in AWS.\nThis includes a Git repository for your source code and a continuous deployment pipeline with test and production environments for your application. It will then initialize a git repository in your local source tree, create an initial commit and push, and wait for a full build and deploy to go green.\nThe process will take several minutes for the initial deploy. While it is deploying, read about Microlith\u0026rsquo;s Architecture.\n The Bootstrap Command Use your application to run the bootstrap command. We will mount the test environment under test.my-domain.com and the production environment under prod.my-domain.com.\nBe sure that your AWS credentials are available to the AWS SDK for Go with no arguments. The configured region will be overridden and the bootstrap process will always deploy to the \u0026ldquo;us-east-1\u0026rdquo; region.\n example.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name prod.my-domain.com  During the bootstrap process, the WHOIS contact of the domain will receive two confirmation emails for ACM certificates, one for test.my-domain.com and one for prod.my-domain.com. The build pipeline will stall until these email confirmations are completed.\n Flags For the bootstrap process, you need to configure the DNS settings for both the test and production environments. For each, you need to pass three arguments to the bootstrap command:\n Validation Domain is the domain name whose contacts will be sent confirmation emails. Hosted Zone ID is the Route53 hosted zone the validation domain is hosted in. DNS Name is the \u0026ldquo;A\u0026rdquo; record that resolves to your application. These can be the validation domain name itself or any subdomain of it.  "
},
{
	"uri": "http://example.org/tutorial/globals/",
	"title": "Globals",
	"tags": [],
	"description": "",
	"content": " Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.\nGlobal channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.\nLet\u0026rsquo;s promote the \u0026ldquo;world\u0026rdquo; service to a global service and the \u0026ldquo;requests\u0026rdquo; channel to a global channel.\nPromote the World Service To promote the \u0026ldquo;world\u0026rdquo; service, we need to use the microlith.GlobalService() function.\nIn your root.go:\nfunc init() { // ... Same as before ... microlith.GlobalService(\u0026quot;world\u0026quot;, worldSvc) }  Promote the Requests Channel To promote the \u0026ldquo;requests\u0026rdquo; channel, we need to use the microlith.GlobalChannel() function.\nIn your root.go:\nvar ( requests = microlith.GlobalChannel(\u0026quot;requests\u0026quot;) // ... Same as before ... )  Ship It Now, the \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel are no longer part of the root domain, but shared across all domains. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Promoted 'world' to a global service\u0026quot; git push origin master  Finally, call your endpoints to verify that your application functions as expected.\ncurl -v https://prod.my-domain.com/  "
},
{
	"uri": "http://example.org/resources/cron/",
	"title": "Cron Jobs",
	"tags": [],
	"description": "",
	"content": " Cron Jobs Support for CloudWatch Schedule Events\n"
},
{
	"uri": "http://example.org/bootstrap/done/",
	"title": "Done",
	"tags": [],
	"description": "",
	"content": " Once the build completes and deploys, your application has been bootstrapped.\nCall Your Application You can validate that it is running by making a HTTP request against your test and production instances. You should receive a \u0026ldquo;Missing authentication token\u0026rdquo; message since no endpoints are defined.\ncurl -v https://test.my-domain.com/ curl -v https://prod.my-domain.com/  Deploy Your Application From now on, git push origin master deploys your application:\ngit add . git commit -m \u0026quot;My changes\u0026quot; git push origin master  If you receive a \u0026ldquo;403\u0026rdquo; when trying to push on Mac OS X, the credentials stored in the Keychain have expired. You will need to delete them to push again, as documented in Step 3 here.\nTeardown The bootstrap process creates three CloudFormation stacks: example-com, example-com-test, and example-com-prod.\nTo tear down the application:\n Empty any buckets in the example-com-test and example-com-prod stacks Delete the example-com-test and example-com-prod stacks Empty the bootstrap bucket in the example-com stack Disable termination protection on the example-com stack Delete the example-com stack  If you delete the \u0026ldquo;example-com\u0026rdquo; stack first, it will delete the IAM role and you will be unable to tear down the \u0026ldquo;example-com-test\u0026rdquo; and \u0026ldquo;example-com-prod\u0026rdquo; stacks. If this happens, you must manually recreate the deleted \u0026ldquo;DeployRole\u0026rdquo; exactly (including the generated name) to tear down the stacks. Termination protection is enabled on the \u0026ldquo;example-com\u0026rdquo; stack to prevent this.\n "
},
{
	"uri": "http://example.org/architecture/globals/",
	"title": "Globals",
	"tags": [],
	"description": "",
	"content": " Some business logic needs to be shared between multiple domains, but services and subdomains cannot access each other. To share logic across the entire application, Microlith provides Global services and channels.\nServices Global services share business logic across domains. They can be called by all services and origins.\nChannels Global channels broadcast messages among all services and origins.\n"
},
{
	"uri": "http://example.org/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Resources Each service is an AWS::Serverless service composed of resources and asynchronous actions. You add resources and actions via the service builder in your Build() method.\n"
},
{
	"uri": "http://example.org/tutorial/subdomains/",
	"title": "Subdomains",
	"tags": [],
	"description": "",
	"content": " Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.\nLet\u0026rsquo;s create a subdomain named \u0026ldquo;sub.domain\u0026rdquo; that returns \u0026ldquo;Hello, subdomain world!\u0026rdquo;. It will have a \u0026ldquo;hello\u0026rdquo; service and use the global \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel. The subdomain\u0026rsquo;s origin will have an endpoint that calls these services and constructs the response.\nCreate the Subdomain First, create a subdomain object. The constructor will take references to the global \u0026ldquo;world\u0026rdquo; service and the \u0026ldquo;requests\u0026rdquo; channel, and will construct a new instance of the \u0026ldquo;hello\u0026rdquo; service. In the builder, we need to register the instance of the \u0026ldquo;hello\u0026rdquo; service with the domain.\nIn ${GOPATH}/src/example.com/sub.domain.go:\npackage main import ( \u0026quot;context\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;github.com/aws/aws-lambda-go/events\u0026quot; \u0026quot;gopkg.in/microlith.v0/sam/tld\u0026quot; \u0026quot;gopkg.in/microlith.v0/sam/tld/strm\u0026quot; \u0026quot;gopkg.in/microlith.v0/sam/tld/rest\u0026quot; ) // A Sub is a subdomain type Sub struct { helloSvc *Word worldSvc *Word requests *strm.Stream endpoint *rest.Endpoint client *rest.Client } // NewSub constructs a new subdomain referencing the \u0026quot;world\u0026quot; global service and // the \u0026quot;requests\u0026quot; global channel. func NewSub(world *Word, requests *strm.Stream) *Sub { return \u0026amp;Sub{ helloSvc: NewWord(\u0026quot;hello\u0026quot;, requests), worldSvc: world, requests: requests, } } // Build implements the tld.DomainBuilder interface. func (sub *Sub) Build(domain *tld.Domain) { domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) }  Add an Endpoint Next, we need to add an endpoint on the subdomain\u0026rsquo;s origin. The handler for the endpoint will call the \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo; services and construct a response to return to the user.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... domain.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { sub.endpoint = scope.Get(\u0026quot;hello-subdomain-world\u0026quot;, sub.handler) }) } func (sub *Sub) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := sub.helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := sub.worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloSubdomainWorld := fmt.Sprintf(\u0026quot;%s, subdomain %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloSubdomainWorld) }  Implement a Client Finally, let\u0026rsquo;s add a public client method to the subdomain so we can call it from the root domain. We\u0026rsquo;ll need to create a REST client in the builder using the tld.DomainClient function.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... var err error sub.client, err = tld.DomainClient(domain) if err != nil { log.Panic(err) } } // HelloSubdomainWorld calls the \u0026quot;hello-subdomain-world\u0026quot; endpoint on the // service. On success, it returns the string \u0026quot;Hello, subdomain world!\u0026quot;. // Otherwise, it returns an error. func (sub *Sub) HelloSubdomainWorld(ctx context.Context) (string, error) { resp, err := sub.client.Call(ctx, sub.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Use the Subdomain Mount an instance of this subdomain in the root domain of your application using the microlith.Subdomain() function.\nIn root.go:\nvar ( // ... Same as before ... subDomain = NewSub(worldSvc, requests) ) func init() { // ... Same as before ... microlith.Subdomain(\u0026quot;sub.domain\u0026quot;, subDomain) }  Call the Subdomain The subdomain can be called from the root domain origin, from services in the root domain, or directly via its domain name. Let\u0026rsquo;s add an endpoint to the root domain\u0026rsquo;s origin that calls the subdomain.\nIn root.go:\nfunc init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { // ... Same as before ... scope.Scope(\u0026quot;/proxy/to/subdomain\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;subdomain\u0026quot;, subHandler) }) }) } func subHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { msg, err := subDomain.HelloSubdomainWorld(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } return rest.Respond(http.StatusOK, msg) }  Ship It Deploy your app:\ngit add . git commit -m \u0026quot;Added a subdomain\u0026quot; git push origin master  Now you can make requests against the subdomain either directly or via the proxy endpoint:\n# Direct request curl -v https://sub.domain.prod.my-domain.com/ # Via the proxy endpoint curl -v https://prod.my-domain.com/proxy/to/subdomain  Adding a subdomain causes Microlith to issue new SSL certificates. During the deploy, the owner of my-domain.com will receive two confirmation emails for certificates, one for sub.domain.test.my-domain.com and one for sub.domain.prod.my-domain.com. The build pipeline will stall until the confirmations are completed.\n "
},
{
	"uri": "http://example.org/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Examples Example Microlith applications.\n"
},
{
	"uri": "http://example.org/resources/inst/",
	"title": "Log Readers",
	"tags": [],
	"description": "",
	"content": " Log Readers Support for CloudWatch Logs Readers\n"
},
{
	"uri": "http://example.org/",
	"title": "Microlith",
	"tags": [],
	"description": "",
	"content": " Microlith Microlith is a AWS::Serverless framework for Go.\nIncluded in the Box  Zero YAML Zero configuration Simple API Powerful service-oriented model Secure, best-practices testing and production environments \u0026ldquo;Push to prod\u0026rdquo; Continuous Deployment  "
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]