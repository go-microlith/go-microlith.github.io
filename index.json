[
{
	"uri": "http://microlith-framework.com/examples/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " The complete code from the tutorial is available in the  tutorial.com repository.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/tutorial.com.\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; git clone https://github.com/go-microlith/tutorial.com \u0026quot;${GOPATH}/src/tutorial.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/tutorial.com/.git/\u0026quot; # Build the application go install tutorial.com  Bootstrap Assuming you own the domain name my-domain.com hosted in zone Z1234567890, use:\ntutorial.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name tutorial.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name tutorial.com.prod.my-domain.com  API The APIs for each subdomain are documented below.\nThis application is deployed live at https://tutorial.com.prod.microlith-framework.com\n Root Domain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, world!\u0026rdquo;   GET /proxy/to/subdomain Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    Subdomain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    "
},
{
	"uri": "http://microlith-framework.com/design/microservices/",
	"title": "Microservices",
	"tags": [],
	"description": "",
	"content": " Microlith uses a microservices-based model called the Domain model. It has three main concepts: Services, Domains, and Applications.\nServices Services are atomic units of business logic and are the base building block of a Microlith application.\nServices are implemented as AWS::Serverless services, containing resources such as Buckets, Tables, and Streams to store and communicate state.\nA service\u0026rsquo;s external interface is a REST API. Endpoints on the API implement business logic by manipulating buckets, mutating tables, and publishing to streams.\nAsynchronous business logic such as observing objects in a bucket, watching changes to tables, and processing events published to a stream is implemented by attaching Lambdas to resources. Services additionally support non-resource actions, such as scheduling cron jobs and reading Lambdas\u0026rsquo; logs.\nUnlike a standard AWS::Serverless service, the API is not publicly routable. Microlith services must live in a container that makes calls on them, such as a Domain or Application.\nDomains Domains are containers for services. They compose the business logic of the services to build larger, richer, and more complex units of business logic.\nA domain\u0026rsquo;s external interface is a REST API. Endpoints on this API, named the Origin, implement business logic by making calls on the services in the domain.\nServices themselves cannot make calls on their peers in the domain. To coordinate between them, domains provide broadcast Channels. Channels are streams that are shared between all of the services in a domain. Any service can publish events to a channel and/or process events published to a channel.\nApplications Applications are containers for domains. They route traffic to domains and share state between domains. Each Microlith application is a single Application container.\nApplications route traffic using DNS. The origin of every domain is mounted under a unique public DNS name. An application contains at least one domain, called the Root domain. The root domain is mounted under a base DNS name, such as \u0026ldquo;example.com\u0026rdquo;. Applications can contain named subdomains which are mounted relative to the DNS name of root domain, such as \u0026ldquo;foo.example.com\u0026rdquo;, \u0026ldquo;bar.example.com\u0026rdquo;, and \u0026ldquo;foo.bar.example.com\u0026rdquo;.\nTo coordinate between domains, applications provide Globals. The globals are a set of services and channels that make a \u0026ldquo;pseudo-domain\u0026rdquo; that is shared between all domains. Origins can call global services just like their internal services, and services can use global channels just like normal channels. Global services can also be called directly by services in a domain.\n"
},
{
	"uri": "http://microlith-framework.com/resources/blob/",
	"title": "Buckets",
	"tags": [],
	"description": "",
	"content": " Create a bucket by calling Bucket() on a service builder with a unique bucket name.\nimages := service.Bucket(\u0026quot;images\u0026quot;)  The returned object is used to create clients and to attach observers.\nManipulators To Get(), Put(), or Delete() an object from a bucket, use a Manipulator.\nmnip := blob.NewManipulator(images) contents, err := mnip.Get(ctx, \u0026quot;/microlith/logo.png\u0026quot;) if err != nil { log.Panic(err) } defer contents.Close() os.Copy(os.Stdout, contents)  Observers Observe objects added, updated, or deleted from buckets by calling the Observer() function on a service builder, giving it a unique observer name and an S3 Lambda function. Use the returned observer to Observe() events on a bucket.\nimageAdded := service.Observer(\u0026quot;image-added\u0026quot;, func(ctx context.Context, evt events.S3Event) error { for _, record := range evt.Records { fmt.Printf(\u0026quot;Image %q added\u0026quot;, record.S3.Object.Key) } return nil }) imageAdded.Observe(images, blob.EventObjectCreated)  Observer Lambdas cannot access buckets due to a circular dependency in CloudFormation.\n Name Buckets are created with an AWS-assigned bucket name. This name is available at runtime via the BucketName() function.\nclient := s3.New(session.New()) bucketName := blob.BucketName(images) client.GetObject(\u0026amp;s3.GetObjectInput{ Bucket: aws.String(bucketName), // ... })  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/go_get/",
	"title": "Get Microlith",
	"tags": [],
	"description": "",
	"content": "Microlith is a standard Go library. Just use \u0026ldquo;go get\u0026rdquo;:\ngo get gopkg.in/microlith.v0  "
},
{
	"uri": "http://microlith-framework.com/tutorial/root/",
	"title": "Hello, world!",
	"tags": [],
	"description": "",
	"content": " We will be creating a Hello World application. Our application needs to respond to GET / with a 200 and the string \u0026ldquo;Hello, world!\u0026rdquo;. As we refactor the application throughout the tutorial, it should still return the same response.\nTo start, we will add a single \u0026ldquo;Hello, world!\u0026rdquo; endpoint to our application and redeploy. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level microlith package.\nThe Handler First, we will create a handler function. The handler function must match the signature of a API Gateway Lambda. The body of the handler uses the Respond() helper to return a 200 response code and the string \u0026ldquo;Hello, world!\u0026rdquo; This helper automatically encodes the response body as JSON.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Hello, world!\u0026quot;) }  The Endpoint Next, we will add a single endpoint at \u0026ldquo;GET /\u0026rdquo; named \u0026ldquo;hello-world\u0026rdquo; and pass the handler function.\nTo define endpoints on the origin, use the microlith.Scope() function. This function takes a path and a builder that provides a Swagger-based DSL for defining a REST API. Endpoints are defined using methods named after HTTP verbs (such as Get(), Put(), etc.) For each endpoint defined, you must pass a unique endpoint name and a handler function.\nfunc init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;hello-world\u0026quot;, handler) }) }  Ship It That\u0026rsquo;s all there is to adding an endpoint. Now you are ready to deploy your app:\ngit add . git commit -m \u0026quot;Added my first endpoint\u0026quot; git push origin master  Once your application has deployed, you can make requests against your endpoint:\ncurl https://prod.my-domain.com/  You should receive a response of \u0026ldquo;Hello, world!\u0026rdquo;\nFreshly deployed Lambdas perform a cold start when the first request is received. When manual testing, you application may return a 500 Internal Server Error on the first few requests after deployment until the Lambdas warm up. If it does, wait a few seconds and retry the request a couple of times until it returns the expected response.\n "
},
{
	"uri": "http://microlith-framework.com/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Microlith is a batteries-included AWS::Serverless framework for Go.\n Zero YAML Zero configuration (*) Simple API Powerful service-oriented model Secure, best-practices testing and production environments \u0026ldquo;Push to prod\u0026rdquo; Continuous Deployment  The documentation will take you through bootstrapping your first application, briefly introduce Microlith\u0026rsquo;s design, and then take you through a guided tutorial of using Microlith.\nQuestions? Problems? Email the list at go-serverless@microlith-framework.com\n"
},
{
	"uri": "http://microlith-framework.com/examples/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": " A blogging application with social features is available in the  blog.com repository.\nIt provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (\u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, etc.) on both posts and comments.\nClone The repository should be cloned to the root of your Go workspace\u0026rsquo;s source tree, i.e. ${GOPATH}/src/blog.com:\n# Clone the repo to the root of your Go workspace's source tree mkdir -p \u0026quot;${GOPATH}/src/blog.com\u0026quot; git clone https://github.com/go-microlith/blog.com \u0026quot;${GOPATH}/src/blog.com\u0026quot; # Microlith will recreate this rm -rf \u0026quot;${GOPATH}/src/blog.com/.git/\u0026quot; # Build the application go install blog.com  Bootstrap blog.com bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name blog.com.test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name blog.com.prod.my-domain.com  API This application is deployed live to https://blog.com.prod.microlith-framework.com/\n Root Domain    Method URL Example Request Body Description     GET /posts N/A Get all blog posts with comments and reactions   POST /posts {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The post body\u0026rdquo;} Create a blog post   GET /posts/{post-id} N/A Get a specific blog post   PUT /posts/{post-id} {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;Updated body\u0026rdquo;} Update the contents of a blog post   DELETE /posts/{post-id} N/A Delete a specific blog post   POST /posts/{post-id}/like N/A React to a blog post with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/love N/A React to a blog post with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/haha N/A React to a blog post with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/wow N/A React to a blog post with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/sad N/A React to a blog post with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/angry N/A React to a blog post with a \u0026ldquo;Angry\u0026rdquo;   POST /posts/{post-id}/comments {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The comment\u0026rdquo;} Comment on a blog post   POST /posts/{post-id}/comments/{comment-id}/like N/A React to a comment with a \u0026ldquo;Like\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/love N/A React to a comment with a \u0026ldquo;Love\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/haha N/A React to a comment with a \u0026ldquo;Haha\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/wow N/A React to a comment with a \u0026ldquo;Wow\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/sad N/A React to a comment with a \u0026ldquo;Sad\u0026rdquo;   POST /posts/{post-id}/comments/{comment-id}/angry N/A React to a comment with a \u0026ldquo;Angry\u0026rdquo;    Implementation This application is implemented with a single service in the root domain, two global services, and a global channel.\nThe posts service in the root domain provides CRUD operations on blog posts. It is backed by a single DynamoDB table to store the posts.\nThe comments global service provides the ability to comment on an object and to fetch all of the comments on an object. It is backed by a single DynamoDB table to store the comments. The table has a global secondary index to fetch time-ordered comments on a single object.\nThe reactions global service provides the ability to react to an object and to fetch a summary of the reactions to an object. It is backed by a single DynamoDB table to store the reactions. It lives in the blog.com/reactions package.\nThe object-deleted global channel contains events with the IDs of objects that were deleted. The posts service watches its DynamoDB table for deletes and emits an event on the channel when one is detected. The comments and reactions service processes the channel and purges any comments on and reactions to the deleted objects. The comments service also watches its DynamoDB table for deletes and emits events on the channel so that reactions to comments are also deleted.\nThe origin provides a complete API for the user. The list-posts endpoint fetches the posts along with their comments and reactions to return them to the user. The rest of the endpoints are proxies to service endpoints to interact with the returned posts.\n"
},
{
	"uri": "http://microlith-framework.com/design/monolith/",
	"title": "Monolith",
	"tags": [],
	"description": "",
	"content": " Microlith packages an entire application into a single executable binary. It does this by taking advantage of the init/main phase distinction in Go.\nMicrolith represents a Domain model application as a tree of Go objects. During the init phase, Microlith provides a builder DSL to construct this tree. Lambda functions are given as Go callback functions. The init phase ends when microlith.Main() is called.\nThe main phase handles converting the tree of objects into CloudFormation templates, deploying it to AWS in a Serverless pattern, and executing Lambda functions. This phase of the executable is completely controlled by the framework. The only user code called are the callbacks provided during the init phase.\nInit Phase The init phase must build the tree deterministically. Microlith relies on every running instance of the executable having an identical copy of this tree. Non-determinism leads to undefined behavior.\nThe init phase will be run on every process start in multiple environments. It must not perform operations requiring external dependencies such as I/O, and should avoid complex, time-consuming algorithms.\nThe init phase must fail fast. Any errors encountered by Microlith during this phase will result in a panic(). Any user errors should likewise result in a panic, and any calls to recover() should re-panic.\nMain Phase Microlith deploys each callback as a separate Lambda function. Each function must be designed as if it was in a stand-alone executable and must not must not share mutable runtime state between functions. For example, mutating a shared variable in one function will not be reflected in other functions.\nBecause AWS Lambda can start and stop function processes at will, all non-local state must be considered transient between requests. For example, incrementing a private counter variable on every request will not behave as expected. All Lambdas must assume they are processing the first and only request.\n"
},
{
	"uri": "http://microlith-framework.com/tutorial/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " The origin API implements its business logic by making calls on services in the domain. It uses the results of those calls to create a response for the user.\nLet\u0026rsquo;s refactor our domain into services which perform the work of creating words. Then we\u0026rsquo;ll refactor our origin endpoint to use those services to build our \u0026ldquo;Hello, world!\u0026rdquo; response.\nThe \u0026ldquo;word\u0026rdquo; Service We will create a \u0026ldquo;word\u0026rdquo; service that returns a fixed word. It will have one endpoint which returns the word as a string and a public method that calls the endpoint.\nAt the code level, a service is an object which implements the tld.ServiceBuilder interface. The Build() method is called when the service is registered with a domain. It is passed a builder to define the service.\ntype Word struct { word string client *rest.Client endpoint *rest.Endpoint } func NewWord(word string) *Word { return \u0026amp;Word{ word: word, } } func (word *Word) Build(service *tld.Service) { // TODO }  Add An Endpoint We will add an endpoint to the service that returns the word. This largely mirrors adding an endpoint to the origin: we will create a handler and then wire the endpoint using the builder.\nHandler The handler function for the endpoint will be a private instance method on the service object. It will simply return a 200 OK with the word as JSON.\nfunc (word *Word) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, word.word) }  Builder Use the Scope() method on the service builder to add an endpoint. This method behaves just like the microlith.Scope() function in the origin.\nWe will capture the returned endpoint value in an instance variable so we can use it to make calls on the \u0026ldquo;word\u0026rdquo; endpoint.\nfunc (word *Word) Build(service *tld.Service) { service.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { word.endpoint = scope.Get(\u0026quot;word\u0026quot;, word.handler) }) }  Client Method We will implement a public instance method that call the \u0026ldquo;word\u0026rdquo; endpoint and return the response body. To make calls on the service, we need to create a REST client using the builder.\nBuilder Use the tld.ServiceClient() function create a rest.Client in your service builder. We will use this client to make calls against the service.\nfunc (word *Word) Build(service *tld.Service) { // ... Same as before ... var err error word.client, err = tld.ServiceClient(service) if err != nil { log.Panic(err) } }  Client Use the client created in the builder to Call() endpoints. The returned value is a standard http.Response. Microlith provides the ResponseBody() and ErrorResponse() helpers to deserialize the contents of the response body either as an object or an error, respectively.\nfunc (word *Word) Word(ctx context.Context) (string, error) { resp, err := word.client.Call(ctx, word.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Origin We can now use the \u0026ldquo;word\u0026rdquo; service in our root domain to factor out the creation of our words.\nWe will create two instances of the service, one returning \u0026ldquo;hello\u0026rdquo; and the other \u0026ldquo;world\u0026rdquo;. Then, we will call those from our origin handler to construct the \u0026ldquo;Hello, world!\u0026rdquo; response for the user.\nServices First, you must create instances of the services and register them with your domain using the microlith.Service() function.\nvar ( helloSvc = NewWord(\u0026quot;hello\u0026quot;) worldSvc = NewWord(\u0026quot;world\u0026quot;) ) func init() { // ... Same as before ... microlith.Service(\u0026quot;hello\u0026quot;, helloSvc) microlith.Service(\u0026quot;world\u0026quot;, worldSvc) }  Handler In the \u0026ldquo;hello-world\u0026rdquo; handler, use the client methods on your service objects to call the services. Use the words returned from the service calls to construct the response to the user.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloWorld := fmt.Sprintf(\u0026quot;%s, %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloWorld) }  Ship It That\u0026rsquo;s all it takes to factor into services. You should be ready to deploy.\ngit add . git commit -m \u0026quot;Factored into services\u0026quot; git push origin master  Once deployed, you can make requests against your domain. You should see the same response as before.\ncurl https://prod.my-domain.com/  You might notice that this deploy takes longer than the last deploy. This is because Microlith uses safe Lambda deploys. By default, the test environment transitions traffic using the \u0026ldquo;AllAtOnce\u0026rdquo; configuration and the production environment uses the \u0026ldquo;Canary10Percent5Minutes\u0026rdquo; configuration. These are both configurable via the bootstrap process.\n "
},
{
	"uri": "http://microlith-framework.com/resources/strm/",
	"title": "Streams",
	"tags": [],
	"description": "",
	"content": " Create a stream by calling Stream() on a service builder with a unique stream name:\nuserSignups := service.Stream(\u0026quot;user-signups\u0026quot;)  The returned object is used to create clients and to attach processors.\nPublishers To Publish() messages to a stream, use a Publisher. Publishers automatically batch messages. To ensure that any pending messages are published, defer a call to Flush().\npublisher := strm.NewPublisher(userSignups) defer publisher.Flush(ctx) signup := \u0026amp;UserSignup{ Email: \u0026quot;john@doe.com\u0026quot;, At: time.Now(), } if err := publisher.Publish(ctx, \u0026quot;partition-key\u0026quot;, signup); err != nil { log.Panic(err) }  Processors Process events from streams by calling the Processor() method on a service builder with a unique processor name and a Kinesis Lambda function. Use the returned processor to Process() a stream.\nMessages are given to processors in batches. To iterate over the batch, create a Scanner.\nuserSignedUp := service.Processor(\u0026quot;user-signed-up\u0026quot;, func(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { var partitionKey string signup := new(UserSignup) if err := scanner.Scan(\u0026amp;partitionKey, signup); err != nil { return err } fmt.Printf(\u0026quot;User %q signed up at %s\\n\u0026quot;, signup.Email, signup.At.Format(time.RFC3339)) } return nil }) userSignedUp.Process(userSignups, strm.StartingPositionTrimHorizon)  Name Streams are created with an AWS-assigned stream name. This name is available at runtime via the StreamName() function.\nclient := kinesis.New(session.New()) streamName := strm.StreamName(userSignups) client.PutRecords(\u0026amp;kinesis.PutRecordsInput{ StreamName: aws.String(streamName), // ... })  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/create/",
	"title": "Your First Application",
	"tags": [],
	"description": "",
	"content": " Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com.\nCreate an Application To create an application, create an executable in ${GOPATH}/src/example.com/main.go and call microlith.Main():\npackage main import ( microlith \u0026quot;gopkg.in/microlith.v0\u0026quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, \u0026ldquo;example.com\u0026rdquo;.\nThe import path of the source code is also significant to Microlith. By default, the main executable must live in the root of your repo at the root of your Go workspace\u0026rsquo;s source tree. In this case, \u0026ldquo;${GOPATH}/src/example.com\u0026rdquo;\nBuild Now, build your application:\ngo install example.com  Your application is now ready to be bootstrapped. Before you can do that, you need to set up Route53.\n"
},
{
	"uri": "http://microlith-framework.com/bootstrap/",
	"title": "Bootstrap",
	"tags": [],
	"description": "",
	"content": "Bootstrap will step you through getting your first Microlith application set up via the automated bootstrap process. By the end of the bootstrap, you will be able to \u0026ldquo;push to prod\u0026rdquo;:\n# Deploy your application git add . git commit -m \u0026quot;My changes\u0026quot; git push origin master # Use your test and production environments curl https://test.my-domain.com/ curl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " Design Microlith is a framework for building scaled, multi-service Software-as-a-Service (SaaS) applications. It simplifies writing and delivering these application by combining a microservice-based model with a monolithic application structure.\n"
},
{
	"uri": "http://microlith-framework.com/tutorial/channels/",
	"title": "Channels",
	"tags": [],
	"description": "",
	"content": " Channels are streams shared between all services in a domain. Services use channels to communicate between each other. Any service can publish events to or process events from a channel. Additionally, the origin can publish events to a channel.\nLet\u0026rsquo;s create a channel for request events. The \u0026ldquo;hello-world\u0026rdquo; endpoint in the origin will publish an event every request. The \u0026ldquo;word\u0026rdquo; service will process the events and write them out to the logs.\nCreate a Channel First, create an event type to represent requests. We will simply record when the request occurred.\ntype Request struct { At time.Time }  Use the microlith.Channel() function to create a channel.\nvar requests = microlith.Channel(\u0026quot;requests\u0026quot;)  The \u0026ldquo;word\u0026rdquo; Service The \u0026ldquo;word\u0026rdquo; service needs to be refactored to write the request events to the logs. We need to get a reference to the channel and then add a processor to log out the events.\nConstructor First, update the constructor for the word service so that it takes the channel as an argument. The value will be needed in the builder, so we place it in an instance variable.\ntype Word struct { // ... Same as before ... requests *strm.Stream } func NewWord(word string, requests *strm.Stream) *Word { return \u0026amp;Word{ word: word, requests: requests, } }  Processor Now that the service has a reference to the channel, it can add a strm.Processor to write the events to the log.\nHandler Create a Kinesis Lambda to write requests to the logs. Like the handler for the endpoint, this will be a private instance method on our service.\nEvents are passed as batches. Create a Scanner to iterate over the batch.\nfunc (word *Word) processRequests(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { partitionKey := \u0026quot;\u0026quot; request := new(Request) if err := scanner.Scan(\u0026amp;partitionKey, request); err != nil { return err } log.Printf(\u0026quot;Request made at %s\u0026quot;, request.At.Format(time.RFC3339Nano)) } return nil }  Builder Process the events in the channel by calling the Processor() method on the service builder with a unique processor name and the handler. Use the returned processor to Process() the request events on the channel.\nfunc (word *Word) Build(service *tld.Service) { // ... Same as before ... processor := service.Processor(\u0026quot;requests\u0026quot;, word.processRequests) processor.Process(word.requests, strm.StartingPositionTrimHorizon) }  Root Domain Now that the \u0026ldquo;word\u0026rdquo; service is updated to subscribe to the channel, we need to provide the channel to the instances of the \u0026ldquo;word\u0026rdquo; service and start publishing events from the \u0026ldquo;hello-world\u0026rdquo; endpoint.\nPass the Channel Use the new constructors to pass the channel to the services.\nvar ( helloSvc = NewWord(\u0026quot;hello\u0026quot;, requests) worldSvc = NewWord(\u0026quot;world\u0026quot;, requests) )  Publish Events Create a strm.Publisher to publish messages to the channel.\nvar publisher = strm.NewPublisher(requests)  Update the \u0026ldquo;hello-world\u0026rdquo; handler to Publish() events to the channel. Defer a call to Flush() to ensure that any batched messages are sent.\nfunc handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { defer publisher.Flush(ctx) if err := publisher.Publish(ctx, \u0026quot;partition-key\u0026quot;, \u0026amp;Request{At: time.Now()}); err != nil { return rest.Respond(http.StatusInternalServerError, err) } // ... Same as before ... }  Ship It Now both services will process an event every time a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Added a channel\u0026quot; git push origin master  Make a request against your application and the processors will soon emit a message to their CloudWatch logs.\ncurl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/route53/",
	"title": "Route53",
	"tags": [],
	"description": "",
	"content": " * Almost Zero Configuration\nMicrolith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once complete, the configuration can be reused for all of your Microlith applications.\nYou will need the Domain Name and the Hosted Zone ID to bootstrap your application. For the remainder of the documentation, we will assume you own my-domain.com in hosted zone Z1234567890.\n Domain Name You will need a domain name hosted in Route53. If you have an existing domain, it can be reused. Microlith will not alter the settings of the domain name, only manage a set of subdomain \u0026ldquo;A\u0026rdquo; records for each application.\nRegister a Domain in the AWS Console To register or transfer a domain name from the AWS Console:\n Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Click either the \u0026ldquo;Register Domain\u0026rdquo; or \u0026ldquo;Transfer Domain\u0026rdquo; button Follow the prompts  Email Validation Microlith issues signed SSL certificates for your domain. To validate domain ownership, Microlith uses AWS Certificate Manager\u0026rsquo;s email validation mechanism. You must have a valid contact email able to respond to confirmation emails. There are two options, one if you receive email at the domain and another if you don\u0026rsquo;t.\nAlias If you receive email at \u0026ldquo;my-domain.com\u0026rdquo;, you may receive confirmation emails automatically. By default, Amazon will send confirmation emails to:\n administrator@my-domain.com hostmaster@my-domain.com postmaster@my-domain.com webmaster@my-domain.com admin@my-domain.com  If these email addresses are not valid at your domain name, you can configure an email alias for one or more of them. Otherwise, you must fall back to the WHOIS mechanism.\nWHOIS If you do not receive email at your domain, you must configure your WHOIS information.\nYour domain name must have a valid Domain, Technical, and/or Administrative contact with an email address. You must explicitly disable privacy protection on these contacts so the email addresses are visible in the WHOIS database.\nConfigure WHOIS in the AWS Console  Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Choose the domain name you plan to use for Microlith Click the \u0026ldquo;Edit Contacts\u0026rdquo; button Add email addresses to your Domain, Technical, and/or Administrative contacts Set \u0026ldquo;Privacy Protection\u0026rdquo; to \u0026ldquo;Disable\u0026rdquo; on the contacts Click the \u0026ldquo;Save\u0026rdquo; button Wait for the email confirmation that the change has taken effect  The email confirmation in the final step will go to the email address associated with the AWS user/account that made the change, not to the email address set in your WHOIS information.\n"
},
{
	"uri": "http://microlith-framework.com/resources/stor/",
	"title": "Tables",
	"tags": [],
	"description": "",
	"content": " Create a table by calling the Table() method on a service builder.\nTables are created with a hash (\u0026ldquo;partition\u0026rdquo;) key and an optional range (\u0026ldquo;sort\u0026rdquo;) key given as Attributes. Attributes can be created with the StringAttribute(), NumberAttribute(), and BinaryAttribute() functions.\nThe streaming configuration must also be provided when the table is declared by passing a ChangeType value.\nvar artistKey = stor.StringAttribute(\u0026quot;Artist\u0026quot;) var nameKey = stor.StringAttribute(\u0026quot;Name\u0026quot;) var albums = service.Table(\u0026quot;albums\u0026quot;, artistKey, nameKey, stor.ChangeTypeNewAndOld)  Secondary indexes are created by calling the GlobalIndex() and LocalIndex() methods on a table. Like tables, global indexes are created with a hash key and an optional range key. These may be any attributes that are present in the base table. Local indexes are created with a non-optional range key. The hash key is automatically the hash key of the base table.\nIndexes project fields from the base table into the index. The projection must be provided at index creation. The constructors for indexes take a ProjectionType as their final argument. For the \u0026ldquo;Include\u0026rdquo; projection type, the names of the attributes to project are taken as varargs.\nvar yearKey = stor.NumberAttribute(\u0026quot;Year\u0026quot;) var albumsByYear = albums.GlobalIndex(\u0026quot;albums-by-year\u0026quot;, yearKey, nameKey, stor.ProjectionTypeInclude, \u0026quot;Artist\u0026quot;) var releaseOrder = albums.LocalIndex(\u0026quot;release-order\u0026quot;, yearKey, stor.ProjectionTypeInclude, \u0026quot;Name\u0026quot;)  The returned table and index objects are used to create clients and to attach watchers.\nMutator To interact with a table, create a Mutator. Mutators support CRUD operations (Get(), Put(), Update(), and Delete()) as well as Query oprations (Query() and Scan()). Batch operations on tables are provided via the top-level GetBatch() and WriteBatch() functions.\nmutator := stor.NewMutator(albums) album := Album{ Name: \u0026quot;Such Sweet Thunder\u0026quot;, Artist: \u0026quot;Duke Ellington and His Orchestra\u0026quot;, Year: 1957, CreatedAt: time.Now(), UpdatedAt: time.Now(), } if err := mutator.Put(ctx, album); err != nil { log.Panic(err) }  For indexes, create a Querier. Queriers are limited to the query and scan operations only.\nalbumsByYearQuerier := stor.NewQuerier(albumsByYear) releaseOrderQuerier := stor.NewQuerier(releaseOrder)  Watchers Watch changes to tables by calling Watcher() on a service builder with a unique watcher name and a DynamoDB Lambda function. Use the returned watcher to Watch() a table. Change streaming must be enabled (i.e., not ChangeTypeNone) on watched tables.\nOnly tables support watchers. Watching changes on a secondary index is not supported.\nalbumAdded := service.Watcher(\u0026quot;album-added\u0026quot;, func(ctx context.Context, evt events.DynamoDBEvent) error { for _, record := range evt.Records { if record.EventName == string(events.DynamoDBOperationTypeInsert) { fmt.Printf(\u0026quot;Album %q by %q added\\n\u0026quot;, record.Changes.Keys[\u0026quot;Name\u0026quot;], record.Changes.Key[\u0026quot;Artist\u0026quot;]) } } }) albumAdded.Watch(albums, strm.StartingPositionTrimHorizon)  Name Tables are created with an AWS-assigned table name. This name is available at runtime via the TableName() function.\nclient := dynamodb.New(session.New()) tableName := stor.TableName(albums) client.GetItem(\u0026amp;dynamodb.GetItemInput{ Table: aws.String(tableName), // ... })  "
},
{
	"uri": "http://microlith-framework.com/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " Tutorial The tutorial will introduce you to the Microlith API by creating a Hello World application then factoring it into services using Microlith\u0026rsquo;s service-oriented model. By the end of the tutorial, your application will use all of Microlith\u0026rsquo;s service and routing infrastructure.\nThe tutorial focuses on the service model and does not delve into building out service behavior using resources. For an example with non-trivial services, see the blog example.\nThe full source code for the completed tutorial is available here.\n"
},
{
	"uri": "http://microlith-framework.com/resources/rest/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": " APIs follow the AWS API Gateway design, based on Swagger.\nAPIs Define paths in your API using the Scope() method. This method is available on service builders to define service APIs, on domain builders to define domain origins, and via microlith.Scope() to define the root domain\u0026rsquo;s origin API. Within your scopes, use methods named after HTTP methods to add endpoints.\nScopes Scopes are paths, such as \u0026ldquo;/foo\u0026rdquo; or \u0026ldquo;/bar\u0026rdquo;. Paths can be multiple segments, such as \u0026ldquo;/foo/bar\u0026rdquo; and can contain variables, such as \u0026ldquo;/foo/{foo-id}\u0026rdquo;. Create nested scopes by passing a builder function and calling the Scope() method on passed builder.\nservice.Scope(\u0026quot;/foo\u0026quot;, func(scope *rest.Scope) { scope.Scope(\u0026quot;/{foo-id}\u0026quot;, func(scope *rest.Scope) { // ... }) })  It is safe to call Scope() methods multiple times with the same or overlapping paths.\nEndpoints Endpoints are API Gateway Lambda functions that handle HTTP requests. They are created with methods named after HTTP methods.\nHandlers Within the handler functions, use RequestBody() to parse a JSON request body and Respond() to respond using JSON. The path and query parameters and the request headers are available on the request object.\n// Handler function func echoHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { var body map[string]interface{} if err := rest.RequestBody(\u0026amp;body); err != nil { return rest.Respond(http.StatusBadRequest, err) } return rest.Respond(http.StatusOK, body) }  Definition Use the Head(), Get(), Post(), Put(), and Delete() methods on a scope builder to define the endpoints. Each endpoint must have a unique name and a unique combination of path and HTTP method, such as GET /. The value returned from the method is used to make HTTP calls on the endpoint.\nvar echo *rest.Endpoint service.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { echo = scope.Get(\u0026quot;echo\u0026quot;, echoHandler) })  All of the methods take an optional builder to define the endpoint. Use the QueryParameter() and Header() methods to define the parameters for the endpoint. Use the Response() and Header() methods to define the HTTP responses. The builder object passed is the same value that is returned and can be captured via the builder function.\nservice.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;echo\u0026quot;, echoHandler, func(endpoint *rest.Endpoint) { endpoint.QueryParameter(\u0026quot;a-query-param\u0026quot;, false) endpoint.Header(\u0026quot;x-request-header\u0026quot;, false) endpoint.Response(http.StatusOK, func(response *rest.Response) { response.Header(\u0026quot;x-response-header\u0026quot;, false) }) echo = endpoint }) })  Inheritance Request parameters and responses can be defined on scopes. These parameters and responses are inherited by all endpoints in the scope and all nested scopes. Inherited values can be overridden within individual endpoints or nested scopes.\nmicrolith.Scope(\u0026quot;/foo\u0026quot;, func(scope *rest.Scope) { scope.Header(\u0026quot;x-header\u0026quot;, true) scope.Get(\u0026quot;requires-header\u0026quot;, handler) scope.Put(\u0026quot;does-not-require-header\u0026quot;, handler, func(endpoint *rest.Endpoint) { endpoint.Header(\u0026quot;x-header\u0026quot;, false) }) scope.Scope(\u0026quot;/bar\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;requires-header\u0026quot;, handler) }) scope.Scope(\u0026quot;/baz\u0026quot;, func(scope *rest.Scope) { scope.Header(\u0026quot;x-header\u0026quot;, false) scope.Get(\u0026quot;does-not-require-header\u0026quot;, handler) }) })  Clients Create a rest.Client to call an API. To call a service, pass a service builder to the tld.ServiceClient() function. To call the origin of a subdomain, pass a domain builder to the tld.DomainClient() function.\nclient := tld.ServiceClient(service)  Use the client to Call() endpoints on the service. The method takes the endpoint to call, an optional request body, and an optional builder to set PathParameter(), QueryParameter(), and request Header() values.\nresp, err := client.Call(echoEndpoint, requestBody, func(request *Request) { request.QueryParameter(\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;) request.Header(\u0026quot;x-foo\u0026quot;, \u0026quot;bar\u0026quot;) }) if err != nil { log.Panic(err) }  The values returned are the same values returned by http.Client. Use the ResponseBody() and ErrorResponse() helpers to deserialize the response body.\nswitch resp.StatusCode { case http.StatusOK: if err := rest.ResponseBody(resp, \u0026amp;responseBody); err != nil { log.Panic(err) } default: err := rest.ErrorResponse(resp, nil) log.Panic(err) }  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/bootstrap/",
	"title": "Bootstrap Your Application",
	"tags": [],
	"description": "",
	"content": " Your application has a built-in command to deploy itself into a self-hosted AWS environment. This environment includes a Git repository for your source code and a continuous deployment pipeline for your application with test and production environments. The bootstrap process will then initialize a git repository in your local source tree, create an initial commit, push, and wait for a full build and deploy to go green. Finally, it will healthcheck your deployed application.\nThe process will take several minutes for the initial deploy.\nThe Bootstrap Command For the bootstrap command, you need to provide the DNS settings for both the test and production environments. For each, you need to pass three arguments to the bootstrap command:\n Validation Domain is the domain name whose contacts will be sent confirmation emails. Hosted Zone ID is the Route53 hosted zone your domain name is hosted in. DNS Name is the \u0026ldquo;A\u0026rdquo; record that resolves to your application. These can be your domain name itself or any subdomain of it.  Our validation domain and hosted zone ID for both will the the same: my-domain.com and Z1234567890, respectively. For the DNS names, we will mount the test environment under test.my-domain.com and the production environment under prod.my-domain.com.\nBe sure that your AWS credentials are available to the AWS SDK for Go with no arguments. The configured region will be overridden and the bootstrap process will always deploy to the \u0026ldquo;us-east-1\u0026rdquo; region.\n example.com instance bootstrap \\ --test-validation-domain my-domain.com \\ --test-hosted-zone-id Z1234567890 \\ --test-dns-name test.my-domain.com \\ --prod-validation-domain my-domain.com \\ --prod-hosted-zone-id Z1234567890 \\ --prod-dns-name prod.my-domain.com  During the bootstrap process, the contact for the \u0026ldquo;my-domain.com\u0026rdquo; domain will receive two confirmation emails for ACM certificates, one for test.my-domain.com and one for prod.my-domain.com. The build pipeline will stall until these email confirmations are completed.\n "
},
{
	"uri": "http://microlith-framework.com/tutorial/globals/",
	"title": "Globals",
	"tags": [],
	"description": "",
	"content": " Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.\nGlobal channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.\nLet\u0026rsquo;s promote the \u0026ldquo;world\u0026rdquo; service to a global service and the \u0026ldquo;requests\u0026rdquo; channel to a global channel.\nPromote the World Service To promote the \u0026ldquo;world\u0026rdquo; service, we need to use the microlith.GlobalService() function.\nfunc init() { // ... Same as before ... microlith.GlobalService(\u0026quot;world\u0026quot;, worldSvc) }  Promote the Requests Channel To promote the \u0026ldquo;requests\u0026rdquo; channel, we need to use the microlith.GlobalChannel() function.\nvar requests = microlith.GlobalChannel(\u0026quot;requests\u0026quot;)  Ship It Now, the \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel are no longer part of the root domain, but shared across all domains. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Promoted 'world' to a global service\u0026quot; git push origin master  Finally, call your endpoints to verify that your application functions as expected.\ncurl https://prod.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/bootstrap/done/",
	"title": "Done",
	"tags": [],
	"description": "",
	"content": "Congratulations, your application is now bootstrapped! From now on, git push origin master deploys your application:\ngit add . git commit -m \u0026quot;My changes\u0026quot; git push origin master  If you receive a \u0026ldquo;403\u0026rdquo; when trying to push on Mac OS X, the credentials stored in the Keychain have expired. You will need to delete them to push again, as documented in Step 3 here.\n "
},
{
	"uri": "http://microlith-framework.com/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Resources Briefly introduces each of the resources available to construct services. For complete documentation, refer to the GoDocs.\n"
},
{
	"uri": "http://microlith-framework.com/resources/cron/",
	"title": "Schedued Jobs",
	"tags": [],
	"description": "",
	"content": "Schedule a job to run in the background by calling Job() on a service builder, providing a unique job name, a schedule, and a CloudWatch Event Lambda function. The schedule can be a simple time interval or a complex calendar, both expressed using CloudWatch Schedule Expressions.\nservice.Job(\u0026quot;purge-cache\u0026quot;, \u0026quot;rate(15 minutes)\u0026quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { return json.NewEncoder(os.Stdout).Encode(evt.Details) })  "
},
{
	"uri": "http://microlith-framework.com/tutorial/subdomains/",
	"title": "Subdomains",
	"tags": [],
	"description": "",
	"content": " Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.\nLet\u0026rsquo;s create a subdomain named \u0026ldquo;sub.domain\u0026rdquo; that returns \u0026ldquo;Hello, subdomain world!\u0026rdquo;. It will have a \u0026ldquo;hello\u0026rdquo; service and use the global \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel. The subdomain\u0026rsquo;s origin will have an endpoint that calls these services and constructs the response.\nCreate the Subdomain First, create a subdomain object. The constructor will take references to the global \u0026ldquo;world\u0026rdquo; service and the \u0026ldquo;requests\u0026rdquo; channel, and will construct a new instance of the \u0026ldquo;hello\u0026rdquo; service. In the builder, we need to register the instance of the \u0026ldquo;hello\u0026rdquo; service with the domain.\n// A Sub is a subdomain type Sub struct { helloSvc *Word worldSvc *Word requests *strm.Stream endpoint *rest.Endpoint client *rest.Client } // NewSub constructs a new subdomain referencing the \u0026quot;world\u0026quot; global service and // the \u0026quot;requests\u0026quot; global channel. func NewSub(world *Word, requests *strm.Stream) *Sub { return \u0026amp;Sub{ helloSvc: NewWord(\u0026quot;hello\u0026quot;, requests), worldSvc: world, requests: requests, } } // Build implements the tld.DomainBuilder interface. func (sub *Sub) Build(domain *tld.Domain) { domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) }  Add an Endpoint Next, we need to add an endpoint on the subdomain\u0026rsquo;s origin. The handler for the endpoint will call the \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo; services and construct a response to return to the user.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... domain.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { sub.endpoint = scope.Get(\u0026quot;hello-subdomain-world\u0026quot;, sub.handler) }) } func (sub *Sub) handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := sub.helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := sub.worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloSubdomainWorld := fmt.Sprintf(\u0026quot;%s, subdomain %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloSubdomainWorld) }  Implement a Client Finally, let\u0026rsquo;s add a public client method to the subdomain so we can call it from the root domain. We\u0026rsquo;ll need to create a REST client in the builder using the tld.DomainClient function.\nfunc (sub *Sub) Build(domain *tld.Domain) { // ... Same as before ... var err error sub.client, err = tld.DomainClient(domain) if err != nil { log.Panic(err) } } // HelloSubdomainWorld calls the \u0026quot;hello-subdomain-world\u0026quot; endpoint on the // service. On success, it returns the string \u0026quot;Hello, subdomain world!\u0026quot;. // Otherwise, it returns an error. func (sub *Sub) HelloSubdomainWorld(ctx context.Context) (string, error) { resp, err := sub.client.Call(ctx, sub.endpoint, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  Use the Subdomain Mount an instance of this subdomain in the root domain of your application using the microlith.Subdomain() function.\nvar subDomain = NewSub(worldSvc, requests) func init() { // ... Same as before ... microlith.Subdomain(\u0026quot;sub.domain\u0026quot;, subDomain) }  Call the Subdomain The subdomain can be called from the root domain origin, from services in the root domain, or directly via its domain name. Let\u0026rsquo;s add an endpoint to the root domain\u0026rsquo;s origin that calls the subdomain.\nfunc init() { microlith.Scope(\u0026quot;/\u0026quot;, func(scope *rest.Scope) { // ... Same as before ... scope.Scope(\u0026quot;/proxy/to/subdomain\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;subdomain\u0026quot;, subHandler) }) }) } func subHandler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { msg, err := subDomain.HelloSubdomainWorld(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } return rest.Respond(http.StatusOK, msg) }  Ship It Deploy your app:\ngit add . git commit -m \u0026quot;Added a subdomain\u0026quot; git push origin master  Adding a subdomain causes Microlith to issue new SSL certificates. During the deploy, the owner of my-domain.com will receive two confirmation emails for certificates, one for sub.domain.test.my-domain.com and one for sub.domain.prod.my-domain.com. The build pipeline will stall until the confirmations are completed.\n Now you can make requests against the subdomain either directly or via the proxy endpoint:\n# Direct request curl https://sub.domain.prod.my-domain.com/ # Via the proxy endpoint curl https://prod.my-domain.com/proxy/to/subdomain  "
},
{
	"uri": "http://microlith-framework.com/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Examples "
},
{
	"uri": "http://microlith-framework.com/resources/inst/",
	"title": "Log Readers",
	"tags": [],
	"description": "",
	"content": "All console output (standard out and standard error) from Lambdas is captured as CloudWatch Logs. Read Lambdas\u0026rsquo; logs by calling the Reader() method on a service builder, passing a unique reader name and a CloudWatch Logs Lambda function. Use the returned reader to filter and Read() a Lambda\u0026rsquo;s logs.\nonErrors := service.Reader(\u0026quot;on-errors\u0026quot;, func(ctx context.Context, evt events.CloudwatchLogsEvent) error { data, err := evt.AWSLogs.Parse() if err != nil { return err } for _, logEvent := range data.LogEvents { fmt.Printf(\u0026quot;Error found in log group %q: %s\u0026quot;, evt.LogGroup, logEvent.Message) } return nil }) onErrors.Read(imageAdded, \u0026quot;s3 error\u0026quot;) onErrors.Read(userSignedUp, \u0026quot;kinesis error\u0026quot;) onErrors.Read(albumAdded, \u0026quot;dynamodb error\u0026quot;)  "
},
{
	"uri": "http://microlith-framework.com/cleanup/",
	"title": "Teardown Instructions",
	"tags": [],
	"description": "",
	"content": " The teardown for an application is a straightforward manual procedure in the AWS Console.\nThe bootstrap process creates three main CloudFormation stacks: example-com, example-com-test, and example-com-prod. It also creates multiple nested stacks. The stacks must be deleted in the correct order, and user data in a stack must be manually deleted before a stack can be torn down.\nProcess  On Mac OS X, delete the CodeCommit repository key from Keychain, as described in step 3 here. Empty any buckets in the example-com-test and example-com-prod stacks and any of their nested stacks, Delete the example-com-test and example-com-prod stacks root stacks. Their nested stacks will be torn down automatically. Wait for the example-com-test and example-com-prod stacks to fully delete (i.e., disappear from the CloudFormation console) Empty the bootstrap bucket in the example-com stack Disable termination protection on the example-com stack Delete the example-com stack  If you delete the \u0026ldquo;example-com\u0026rdquo; stack before the \u0026ldquo;-test\u0026rdquo; and \u0026ldquo;-prod\u0026rdquo; stacks have been fully deleted, it will delete the IAM role and you will be unable to tear down the \u0026ldquo;example-com-test\u0026rdquo; and \u0026ldquo;example-com-prod\u0026rdquo; stacks. If this happens, you must manually recreate the deleted \u0026ldquo;DeployRole\u0026rdquo; exactly (including the generated name) to tear down the stacks. Termination protection is enabled on the \u0026ldquo;example-com\u0026rdquo; stack to prevent this.\n "
},
{
	"uri": "http://microlith-framework.com/",
	"title": "Microlith",
	"tags": [],
	"description": "",
	"content": " Microlith Simple Serverless\nfunc init() { microlith.Scope(\u0026quot;/microlith\u0026quot;, func(scope *rest.Scope) { scope.Get(\u0026quot;go-serverless\u0026quot;, func(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Go Serverless\u0026quot;) }) }) } func main() { microlith.Main() }  "
},
{
	"uri": "http://microlith-framework.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://microlith-framework.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]