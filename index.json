[
{
	"uri": "http://microlith-framework.com/examples/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " The complete code from the tutorial is available in the  tutorial.com repository.\nDeploy You can deploy this domain directly from GitHub using the bootstrap process. Be sure your GitHub Personal Access Token is configured.\n# Get the app go get -u github.com/go-microlith/tutorial.com # Build the app go install github.com/go-microlith/tutorial.com # Deploy the app tutorial.com instance bootstrap \\ --import-path github.com/go-microlith/tutorial.com \\ --dns-name tutorial.my-domain.com \\ --hosted-zone-id Z1234567890 \\ --validation-domain my-domain.com  API The APIs for each subdomain are documented below.\nThis application is deployed live at https://tutorial.microlith-framework.com\n Root Domain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, world!\u0026rdquo;   GET /proxy/to/subdomain Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    Subdomain    Method URL Description     GET / Returns a 200 OK with a response body of \u0026ldquo;Hello, subdomain world!\u0026rdquo;    "
},
{
	"uri": "http://microlith-framework.com/resources/blob/",
	"title": "Buckets",
	"tags": [],
	"description": "",
	"content": " Create a bucket by calling Bucket() on a service builder with a unique bucket name.\nimages := service.Bucket(\u0026quot;images\u0026quot;)  In Lambda functions, you can Get(), Put(), or Delete() objects in the bucket.\ncontents, err := images.Get(ctx, \u0026quot;/microlith/logo.png\u0026quot;) if err != nil { // ... } defer contents.Close() os.Copy(os.Stdout, contents)  Observers Observers are Lambda functions triggered when objects are added, updated, or deleted from buckets. Create an Observer Lambda by implementing the Observer interface.\nObserver Lambdas cannot Get(), Put(), or Delete() on buckets due to a circular dependency in CloudFormation.\n type imageAdded struct {} func (*imageAdded) Observe(ctx context.Context, evt events.S3Event) error { for _, record := range evt.Records { fmt.Printf(\u0026quot;Image %q added\u0026quot;, record.S3.Object.Key) } return nil }  Register the observer by calling the Observer() function on a service builder, giving it a unique observer name and and an Observer Lambda. Use the builder to Observe() events on buckets.\nservice.Observer(\u0026quot;image-added\u0026quot;, new(imageAdded), func(observer *blob.ObserverBuilder) { observer.Observe(images, blob.EventObjectCreated) })  You can filter the keys observed on a bucket by passing a builder\nservice.Observer(\u0026quot;image-added\u0026quot;, new(imageAdded), func(observer *blob.ObserverBuilder) { observer.Observe(images, blob.EventObjectCreated, func(filter *blob.FilterBuilder) { filter.Prefix(\u0026quot;/uploaded\u0026quot;) filter.Suffix(\u0026quot;.jpg\u0026quot;, \u0026quot;.jpeg\u0026quot;) filter.Suffix(\u0026quot;.gif\u0026quot;) }) })  Name Buckets are created with an AWS-assigned bucket name. This name is available at runtime via the Name() method.\nIt is safe to use alternative S3 clients. The execution role limits Lambdas to ListBucket* action on the buckets in the service and the GetObject*, PutObject*, and DeleteObject* actions on the objects in those buckets.\ns3Client.GetObject(\u0026amp;s3.GetObjectInput{ Bucket: aws.String(images.Name()), // ... })  "
},
{
	"uri": "http://microlith-framework.com/prerequisites/route53/",
	"title": "Route53 DNS",
	"tags": [],
	"description": "",
	"content": " Microlith uses Route53 DNS as its global router. You will need a domain name hosted in Route53 set up for AWS Certificate Manager email validation. This requires a one-time, non-automatable setup. Once complete, the configuration can be reused for all of your Microlith applications.\nDomain Name You will need a domain name hosted in Route53. If you have an existing domain, it can be reused.\nRegister a Domain in the AWS Console To register or transfer a domain name from the AWS Console:\n Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Click either the \u0026ldquo;Register Domain\u0026rdquo; or \u0026ldquo;Transfer Domain\u0026rdquo; button Follow the prompts  Email Validation Microlith issues signed SSL certificates for your domain. To validate domain ownership, Microlith uses AWS Certificate Manager\u0026rsquo;s email validation mechanism. You must have a valid contact email able to respond to confirmation emails. There are two options, one if you receive email at the domain and another if you don\u0026rsquo;t.\nAlias If you receive email at \u0026ldquo;my-domain.com\u0026rdquo;, you may receive confirmation emails automatically. By default, Amazon will send confirmation emails to:\n administrator@my-domain.com hostmaster@my-domain.com postmaster@my-domain.com webmaster@my-domain.com admin@my-domain.com  If these email addresses are not valid at your domain name, you can configure an email alias for one or more of them. Otherwise, you must fall back to the WHOIS mechanism.\nWHOIS If you do not receive email at your domain, you must configure your WHOIS information.\nYour domain name must have a valid Domain, Technical, and/or Administrative contact with an email address. You must explicitly disable privacy protection on these contacts so the email addresses are visible in the WHOIS database.\nOnce complete, you can validate your change with a WHOIS Lookup of your domain name.\nConfigure WHOIS in the AWS Console  Navigate to Route53 Navigate to \u0026ldquo;Registered Domains\u0026rdquo; Choose the domain name you plan to use for Microlith Click the \u0026ldquo;Edit Contacts\u0026rdquo; button Add email addresses to your Domain, Technical, and/or Administrative contacts Set \u0026ldquo;Privacy Protection\u0026rdquo; to \u0026ldquo;Disable\u0026rdquo; on the contacts Click the \u0026ldquo;Save\u0026rdquo; button Wait for the email confirmation that the change has taken effect  The email confirmation in the final step will go to the email address associated with the AWS user/account that made the change, not to the email address set in your WHOIS information.\n"
},
{
	"uri": "http://microlith-framework.com/intro/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": "The leaves of your tree are Sinatra-weight Serverless services. A service is an atomic unit of business logic. It is a REST API, a set of resources, and a set of asynchronous actions.\nYou define services using a builder DSL. Microlith uses a simple, pervasive language to make the API easy to learn and use. You define your API. You add buckets, tables, and streams. You observe objects in buckets, watch changes to tables, and process events from streams. You can even schedule a cron job or read other Lambdas\u0026rsquo; logs.\nHere\u0026rsquo;s a real service that provide comments, taken from the blog example.\nfunc (service *Service) Build(builder *tld.ServiceBuilder) { var on *stor.Index comments := builder.Table(\u0026quot;comments\u0026quot;, stor.String(\u0026quot;ID\u0026quot;), nil, stor.ChangeTypeNewAndOld, func(table *stor.TableBuilder) { on = table.GlobalIndex(\u0026quot;on-object\u0026quot;, stor.String(\u0026quot;On\u0026quot;), stor.String(\u0026quot;CreatedAt\u0026quot;), stor.ProjectionTypeAll) }) lambda := social.WatchForDeletes(service.objectDeleted, func(change events.DynamoDBStreamRecord) string { return change.Keys[\u0026quot;ID\u0026quot;].String() }) builder.Watcher(\u0026quot;watch-for-deletes\u0026quot;, lambda, func(watcher *stor.WatcherBuilder) { watcher.Watch(comments, strm.StartingPositionTrimHorizon) }) builder.Processor(\u0026quot;purge-comments\u0026quot;, social.ObjectDeleted(processors.PurgeComments(comments, on)), func(processor *strm.ProcessorBuilder) { processor.Process(service.objectDeleted, strm.StartingPositionTrimHorizon) }) builder.API(func(api *rest.APIBuilder) { api.Scope(\u0026quot;/comments\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;comments-on\u0026quot;, endpoints.CommentsOn(on), \u0026amp;service.commentsOnEndpoint, func(endpoint *rest.EndpointBuilder) { endpoint.Query(\u0026quot;on\u0026quot;, true) }) scope.Post(\u0026quot;create-comment\u0026quot;, endpoints.CreateComment(comments), \u0026amp;service.createCommentEndpoint) }) }) }  "
},
{
	"uri": "http://microlith-framework.com/intro/",
	"title": "Ship",
	"tags": [],
	"description": "",
	"content": "Microlith is a opinionated AWS::Serverless framework for Go, inspired by Sinatra, Heroku, and Sphero. It uses convention-over-configuration to build scaled, multi-service SaaS applications, and it makes delivering them to production fun.\nIt\u0026rsquo;s designed like a toy: it\u0026rsquo;s simple, intuitive, and has just enough magic to make you smile. You don\u0026rsquo;t need to know Serverless to use Microlith. You don\u0026rsquo;t need to know AWS. You don\u0026rsquo;t even need to know much Go. You can pick up the API in a day and leave all of the AWS heavy-lifting to Microlith.\nThat\u0026rsquo;s because it doesn\u0026rsquo;t work like other Serverless frameworks. You don\u0026rsquo;t create templates, config files, or deploy scripts. You don\u0026rsquo;t write YAML or JSON or TOML. And you don\u0026rsquo;t use the console.\nYou build a tree. In Go. And you ship it.\nThat\u0026rsquo;s it.\n"
},
{
	"uri": "http://microlith-framework.com/examples/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": " A blogging application with social features is available in the  blog.com repository.\nIt provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (\u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, etc.) on both posts and comments.\nDeploy You can deploy this domain directly from GitHub using the bootstrap process. Be sure your GitHub Personal Access Token is configured.\n# Get the app go get -u github.com/go-microlith/blog.com # Build the app go install github.com/go-microlith/blog.com # Deploy the app blog.com instance bootstrap \\ --import-path github.com/go-microlith/blog.com \\ --dns-name blog.my-domain.com \\ --hosted-zone-id Z1234567890 \\ --validation-domain my-domain.com  API This application is deployed live to https://blog.microlith-framework.com/\n Root Domain    Method URL Example Request Body Description     GET /posts N/A Get all blog posts with comments and reactions   POST /posts {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The post body\u0026rdquo;} Create a blog post   GET /posts/{post-id} N/A Get a specific blog post   PUT /posts/{post-id} {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;Updated body\u0026rdquo;} Update the contents of a blog post   DELETE /posts/{post-id} N/A Delete a specific blog post   POST /posts/{post-id}/{reaction} N/A React to a blog post. Valid reactions are \u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, \u0026ldquo;Haha\u0026rdquo;, \u0026ldquo;Wow\u0026rdquo;, \u0026ldquo;Sad\u0026rdquo;, and \u0026ldquo;Angry\u0026rdquo;.   POST /posts/{post-id}/comments {\u0026ldquo;Body\u0026rdquo;:\u0026ldquo;The comment\u0026rdquo;} Comment on a blog post   POST /posts/{post-id}/comments/{comment-id}/{reaction} N/A React to a comment. Valid reactions are \u0026ldquo;Like\u0026rdquo;, \u0026ldquo;Love\u0026rdquo;, \u0026ldquo;Haha\u0026rdquo;, \u0026ldquo;Wow\u0026rdquo;, \u0026ldquo;Sad\u0026rdquo;, and \u0026ldquo;Angry\u0026rdquo;.    Implementation This application is implemented with a single service in the root domain, two global services, and a global channel. The application relies on services in the social-services package.\nServices The \u0026ldquo;posts\u0026rdquo; service in the root domain provides CRUD operations on blog posts. It is backed by a single DynamoDB table to store the posts.\nThe \u0026ldquo;comments\u0026rdquo; global service provides the ability to comment on an object and to fetch all of the comments on an object. It is backed by a single DynamoDB table to store the comments. The table has a global secondary index to fetch time-ordered comments on a single object.\nThe \u0026ldquo;reactions\u0026rdquo; global service provides the ability to react to an object and to fetch a summary of the reactions to an object. It is backed by a single DynamoDB table to store the reactions.\nDeletes The \u0026ldquo;object-deleted\u0026rdquo; global channel contains events with the IDs of objects that have been deleted. It is used to purge deleted data from all of the services in an eventually consistent way.\nThe \u0026ldquo;posts\u0026rdquo; and \u0026ldquo;comments\u0026rdquo; services watch their DynamoDB tables for deletes and emit events on the channel. The \u0026ldquo;comments\u0026rdquo; and \u0026ldquo;reactions\u0026rdquo; service processes the channel and purge comments on and reactions to the deleted objects.\nOrigin The origin provides a complete API for the user. The \u0026ldquo;list-posts\u0026rdquo; endpoint fetches the posts along with their comments and reactions to return them to the user. The rest of the endpoints are proxies to service endpoints to interact with the returned posts.\n"
},
{
	"uri": "http://microlith-framework.com/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": " Prerequisites "
},
{
	"uri": "http://microlith-framework.com/intro/lambdas/",
	"title": "Lambdas",
	"tags": [],
	"description": "",
	"content": "Your business logic is implemented with Lambda functions. Microlith Lambda functions are Go objects that implement a Lambda interface. Each type of Lambda is a specialized single-method interface.\nIn your Lambda functions, you can work with objects in buckets, query and update tables and indexes, publish events to streams, and call endpoints on services. APIs are simple nouns and verbs. They follow the principles of least surprise and of \u0026ldquo;Tell, don\u0026rsquo;t Ask\u0026rdquo;. You Put() items into tables. You rest.Respond() to REST calls. You iterate with Next() and Scan().\nHere\u0026rsquo;s a real REST endpoint Lambda, taken from the same comments service.\ntype createComment struct { comments *stor.Table } func CreateComment(comments *stor.Table) rest.Handler { return \u0026amp;createComment{comments} } func (endpoint *createComment) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { comment := new(social.Comment) if err := rest.RequestBody(req, comment); err != nil { return rest.Respond(http.StatusBadRequest, err) } comment.ID = uuid.New() comment.CreatedAt = time.Now() if err := endpoint.comments.Put(ctx, *comment); err != nil { return rest.Respond(http.StatusInternalServerError, err) } return rest.Respond(http.StatusCreated, comment) }  "
},
{
	"uri": "http://microlith-framework.com/resources/stor/",
	"title": "Tables",
	"tags": [],
	"description": "",
	"content": " Create a table by calling the Table() method on a service builder with a unique table name.\nTables are created with a hash (\u0026ldquo;partition\u0026rdquo;) key and an optional range (\u0026ldquo;sort\u0026rdquo;) key given as Attributes. Attributes can be created with the String(), Number(), and Binary() functions.\nThe streaming configuration must also be provided when the table is declared by passing a ChangeType value.\nvar artistKey = stor.String(\u0026quot;Artist\u0026quot;) var nameKey = stor.String(\u0026quot;Name\u0026quot;) var albums = service.Table(\u0026quot;albums\u0026quot;, artistKey, nameKey, stor.ChangeTypeNewAndOld)  In Lambda functions, you can Get(), Put(), Update(), and Delete() items in the table, as well as Query() and Scan() the table. Batch operations across multiple tables are provided via the top-level GetBatch() and WriteBatch() functions.\nalbum := Album{ Name: \u0026quot;Such Sweet Thunder\u0026quot;, Artist: \u0026quot;Duke Ellington and His Orchestra\u0026quot;, Year: 1957, CreatedAt: time.Now(), UpdatedAt: time.Now(), } if err := albums.Put(ctx, album); err != nil { // ... }  Secondary Indexes Secondary indexes are created by passing a builder function to the Table constructor. A GlobalIndex() is created with a hash key and an optional range key. A LocalIndex() is created with a non-optional range key, and the hash key is automatically the hash key of the base table.\nIndexes project fields from the base table into the index. The projection must be provided at index creation. The constructors for indexes take a ProjectionType as their final argument. For the \u0026ldquo;Include\u0026rdquo; projection type, the names of the attributes to project are taken as varargs.\nvar artistKey = stor.String(\u0026quot;Artist\u0026quot;) var nameKey = stor.String(\u0026quot;Name\u0026quot;) var yearKey = stor.Number(\u0026quot;Year\u0026quot;) var albumsByYear, releaseOrder *stor.Index var albums = service.Table(\u0026quot;albums\u0026quot;, artistKey, nameKey, stor.ChangeTypeNewAndOld, func(table *stor.TableBuilder) { albumsByYear = albums.GlobalIndex(\u0026quot;albums-by-year\u0026quot;, yearKey, nameKey, stor.ProjectionTypeInclude, \u0026quot;Artist\u0026quot;) releaseOrder = albums.LocalIndex(\u0026quot;release-order\u0026quot;, yearKey, stor.ProjectionTypeInclude, \u0026quot;Name\u0026quot;) })  In Lambda functions, you can Query() and Scan() indexes.\nresult, err := albumsByYear.Query(ctx, func(query *stor.QueryBuilder) { query.KeyCondition(expression.Key(\u0026quot;Year\u0026quot;).Equal(expression.Value(\u0026quot;1957\u0026quot;))) }) if err != nil { // ... } fmt.Println(\u0026quot;Albums from 1957:\u0026quot;) var album Album for result.Next() { if err := result.Scan(\u0026amp;album); err != nil { // ... } fmt.Printf(\u0026quot;- %s\\n\u0026quot;, album.Name) }  Watchers Watchers are Lambda functions triggered when items are added, updated, or removed from tables. Create a Watcher Lambda by implementing the Watcher interface.\ntype albumAdded struct {} func (*albumAdded) Watch(ctx context.Context, evt events.DynamoDBEvent) error { for _, record := range evt.Records { if record.EventName == string(events.DynamoDBOperationTypeInsert) { name := record.Changes.Keys[\u0026quot;Name\u0026quot;] artist := record.Changes.Key[\u0026quot;Artist\u0026quot;] fmt.Printf(\u0026quot;Album %q by %q added\\n\u0026quot;, name, artist) } } }  Register the watcher by calling the Watcher() method on a service builder, giving it a unique observer name and a Watcher Lambda. Use the builder to Watch() changes on tables. You must specify a starting position in the change stream when watching a table.\nservice.Watcher(\u0026quot;album-added\u0026quot;, new(albumAdded), func(watcher *stor.WatcherBuilder) { watcher.Watch(albums, strm.StartingPositionTrimHorizon) })  Change streaming must be enabled (i.e., not ChangeTypeNone) on watched tables. Watching changes on a secondary index is not supported.\nName Tables are created with an AWS-assigned table name. This name is available at runtime via the Name() method.\nIt is safe to use alternative DynamoDB clients. The execution role limits Lambdas to GetItem, PutItem, UpdateItem, DeleteItem, Query, Scan, BatchGetItem, and BatchWriteItem on tables in the service, Query and Scan on secondary indexes, ListStreams on all tables, and GetRecords, GetShardIterator, and DescribeStream on the change streams from tables in the service.\ndynamodbClient.GetItem(\u0026amp;dynamodb.GetItemInput{ Table: aws.String(albums.Name()), // ... })  "
},
{
	"uri": "http://microlith-framework.com/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": " Tutorial "
},
{
	"uri": "http://microlith-framework.com/intro/domain/",
	"title": "Domains",
	"tags": [],
	"description": "",
	"content": "The branches of your tree are domains. A domain is a container for services. It is an origin API, a set of services, and a set of shared broadcast channels. The origin takes traffic and calls on services to implement business logic. Services use the channels to communicate asynchronously.\nYou define domains with a builder DSL. You define your origin API, create channels, and add services. You implement endpoints with Lambdas, just like in services.\nHere\u0026rsquo;s a subdomain you\u0026rsquo;ll build during the tutorial.\nfunc (sub *Sub) Build(domain *tld.DomainBuilder) { sub.requests = domain.Channel(\u0026quot;requests\u0026quot;) sub.helloSvc = NewWord(\u0026quot;hello\u0026quot;, sub.requests) sub.worldSvc = NewWord(\u0026quot;world\u0026quot;, sub.requests) domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) domain.Service(\u0026quot;world\u0026quot;, sub.worldSvc) domain.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;hello-subdomain-world\u0026quot;, newHelloSubdomainWorld(sub.helloSvc, sub.worldSvc, sub.requests), \u0026amp;sub.endpoint) }) }  "
},
{
	"uri": "http://microlith-framework.com/tutorial/bootstrap/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " The tutorial will introduce you to Microlith by building a simple \u0026ldquo;Hello, world!\u0026rdquo; app. It\u0026rsquo;s not fancy: \u0026ldquo;GET /\u0026rdquo; returns \u0026ldquo;Hello, world!\u0026rdquo;. We\u0026rsquo;ll slowly refactor the application to show how to build a Microlith app. For a complete, non-trivial app, see the blog example.\nThe first step is to create an empty app and bootstrap it.\nCreate the Application A Microlith application is just an executable that calls microlith.Main(). Applications are named after domain names, such as \u0026ldquo;tutorial.com\u0026rdquo;.\npackage main import ( microlith \u0026quot;gopkg.in/microlith.v0\u0026quot; ) func main() { microlith.Main() }  Build the application with:\ngo install github.com/go-microlith/tutorial.com  Don\u0026rsquo;t worry if you don\u0026rsquo;t own the domain name \u0026ldquo;tutorial.com\u0026rdquo;. The application name is a logical name. At runtime, you can serve your app from any DNS name.\nBootstrap Microlith applications come with a built-in command to setup continuous deployment to AWS. This command supports several options. At a minimum, you must to pass your DNS information and your import path.\nTo see all options, use the \u0026ldquo;\u0026ndash;help\u0026rdquo; flag.\ntutorial.com instance bootstrap --help  DNS DNS is the only resource managed by the user instead of by Microlith. You need to pass a few AWS identifiers so Microlith knows where to deploy. There are three configuration flags:\n --dns-name is the base DNS name --hosted-zone-id is the Route53 Hosted Zone for \u0026ldquo;A\u0026rdquo; records --validation-domain is the Route53 Domain Name for email validation.  Each app is mounted at a base DNS name, such as \u0026ldquo;example.com\u0026rdquo; or \u0026ldquo;app.example.com\u0026rdquo;. The root domain is mounted at this name and all subdomains are mounted as DNS subdomains. These names are \u0026ldquo;A\u0026rdquo; records managed by Microlith in a Route53 Hosted Zone managed by the user. By default, the base DNS name is the executable name.\nEach app also has a validation domain name. This is a Route53 Domain Name set up for email validation and managed by the user. The contacts of this domain name will be contacted for all ACM Certificates issued. By default, the validation domain is the same as the DNS name.\nImport Path The bootstrap process needs the source code\u0026rsquo;s import path, but can\u0026rsquo;t determine it automatically. Pass it with the --import-path flag.\nBy default, Microlith hosts your source in an AWS CodeCommit repository. If your import path is of the form \u0026ldquo;github.com/\u0026lt;owner\u0026gt;/\u0026lt;repo\u0026gt;\u0026ldquo;, Microlith uses GitHub. The repository must already exist and you must set up your GitHub Personal Access Token for Microlith to access it, even for public repositories.\nThe import path is not persistent across re-bootstraps and must be passed every time.\nBootstrap Command The bootstrap process will always deploy to the \u0026ldquo;us-east-1\u0026rdquo; region.\n Now you can run the bootstrap command. For example, to deploy the \u0026ldquo;github.com/go-microlith/tutorial.com\u0026rdquo; application to \u0026ldquo;tutorial.my-domain.com\u0026rdquo;, you would use the following:\ntutorial.com instance bootstrap \\ --import-path github.com/go-microlith/tutorial.com \\ --dns-name tutorial.my-domain.com \\ --hosted-zone-id Z1234567890 \\ --validation-domain my-domain.com  This command will take several minutes to complete. During the bootstrap process, the contact for the validation domain will receive a confirmation email for an ACM certificate. The bootstrap process will stall until this email confirmation is completed.\nOnce it has completed, you should be able to \u0026ldquo;push to prod\u0026rdquo;:\ngit add . git commit -m \u0026quot;My changes\u0026quot; git push origin master  Re-Bootstrap and Teardown You can adjust bootstrap parameters at any time by re-running bootstrap command with the \u0026ldquo;\u0026ndash;rebootstrap\u0026rdquo; flag and passing the parameters to update. All other parameters will retain their previous values.\nSome parameters will not take effect until the next deploy.\ntutorial.com instance bootstrap --rebootstrap \\ --import-path github.com/go-microlith/tutorial.com \\ --dns-name example.my-domain.com  When you are done with your app (or if the bootstrap process fails), see the teardown instructions to undeploy your application.\n"
},
{
	"uri": "http://microlith-framework.com/prerequisites/github/",
	"title": "GitHub Access Token",
	"tags": [],
	"description": "",
	"content": "Microlith hosts your source code in a git repository. It can either use AWS CodeCommit for this or GitHub.\nTo host on GitHub, you need to create a GitHub Personal Access Token with \u0026ldquo;repo\u0026rdquo; scope. A token is needed for both public and private repositories. Place the token in the GITHUB_OAUTH_TOKEN environment variable.\nexport GITHUB_OAUTH_TOKEN=\u0026quot;\u0026lt;hex-string\u0026gt;\u0026quot;  "
},
{
	"uri": "http://microlith-framework.com/resources/strm/",
	"title": "Streams",
	"tags": [],
	"description": "",
	"content": " Create a stream by calling Stream() on a service builder with a unique stream name\nuserSignups := service.Stream(\u0026quot;user-signups\u0026quot;)  In Lambda functions, you can Publish() messages to a stream. Streams automatically batch messages. To ensure that any pending messages are published, defer a call to Flush().\nsignup := \u0026amp;UserSignup{ Email: \u0026quot;john@doe.com\u0026quot;, At: time.Now(), } defer userSignups.Flush(ctx) if err := userSignups.Publish(ctx, \u0026quot;partition-key\u0026quot;, signup); err != nil { // ... }  Processors Processors are Lambda functions that are triggered when messages are published to streams. Create a Processor Lambda by implementing the Processor interface.\nEvents are batched before being passed to the processor. Use a Scanner to iterate over the batch.\ntype userSignedUp struct {} func (*userSignedUp) Process(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { var partitionKey string signup := new(UserSignup) if err := scanner.Scan(\u0026amp;partitionKey, signup); err != nil { return err } fmt.Printf(\u0026quot;User %q signed up at %s\\n\u0026quot;, signup.Email, signup.At.Format(time.RFC3339)) } return nil }  Register the processor by calling the Processor() method on a service builder, giving it a unique processor name and a Processor Lambda. Use the builder to Process() streams. You must specify a starting position in the change stream when processing a stream.\nservice.Processor(\u0026quot;user-signed-up\u0026quot;, new(userSignedUp), func(stream *strm.StreamBuilder) { stream.Process(userSignups, strm.StartingPositionTrimHorizon) })  Name Streams are created with an AWS-assigned stream name. This name is available at runtime via the Name() method.\nIt is safe to use alternative Kinesis clients. The execution role limits Lambdas to ListStreams on all streams, and PutRecord, PutRecords, GetRecords, GetShardIterator, and DescribeStream on streams in the service, channels in the domain, and global channels.\nkinesisClient.PutRecords(\u0026amp;kinesis.PutRecordsInput{ StreamName: aws.String(userSignups.Name()), // ... })  "
},
{
	"uri": "http://microlith-framework.com/intro/application/",
	"title": "Application",
	"tags": [],
	"description": "",
	"content": "The root of your tree is the application. An application is a container for domains. It has a root domain and a set of subdomains, and it routes traffic to them using DNS. It also has a global \u0026ldquo;pseudo-domain\u0026rdquo; with services and channels that are shared between all domains.\nThe application is defined using the DSL in the top-level microlith package. You define your root domain using the domain DSL, plus you add global services, create global channels and register subdomains.\nHere\u0026rsquo;s the blog application.\nfunc init() { deleted := microlith.GlobalChannel(\u0026quot;object-deleted\u0026quot;) commentsSvc := comments.New(deleted) reactionsSvc := reactions.New(deleted) postsSvc := posts.New(deleted) microlith.GlobalService(\u0026quot;comments\u0026quot;, commentsSvc) microlith.GlobalService(\u0026quot;reactions\u0026quot;, reactionsSvc) microlith.Service(\u0026quot;posts\u0026quot;, postsSvc) microlith.Origin(func(api *rest.APIBuilder) { api.Scope(\u0026quot;/posts\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;list-posts\u0026quot;, endpoints.ListPosts(postsSvc, commentsSvc, reactionsSvc), nil) scope.Post(\u0026quot;create-post\u0026quot;, endpoints.CreatePost(postsSvc), nil) scope.Scope(\u0026quot;/{post-id}\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;show-post\u0026quot;, endpoints.ShowPost(postsSvc), nil) scope.Put(\u0026quot;update-post\u0026quot;, endpoints.UpdatePost(postsSvc), nil) scope.Delete(\u0026quot;delete-post\u0026quot;, endpoints.DeletePost(postsSvc), nil) scope.Scope(\u0026quot;/comments\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Post(\u0026quot;comment-on-post\u0026quot;, comments.CommentOn(commentsSvc, \u0026quot;post-id\u0026quot;), nil) scope.Scope(\u0026quot;/{comment-id}/{reaction}\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Post(\u0026quot;react-to-comment\u0026quot;, reactions.ReactTo(\u0026quot;comment-id\u0026quot;, \u0026quot;reaction\u0026quot;, reactionsSvc), nil) }) }) scope.Scope(\u0026quot;/{reaction}\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Post(\u0026quot;react-to-post\u0026quot;, reactions.ReactTo(\u0026quot;post-id\u0026quot;, \u0026quot;reaction\u0026quot;, reactionsSvc), nil) }) }) }) }) }  "
},
{
	"uri": "http://microlith-framework.com/resources/rest/",
	"title": "Endpoints",
	"tags": [],
	"description": "",
	"content": " Endpoints are Lambda functions triggered on HTTP requests. Create an Endpoint Lambda by implementing the Handler interface.\nWithin the handler Lambda functions, you can parse a RequestBody() as JSON and Respond() with JSON or an error. The path and query parameters and the request headers are available on the request object.\ntype echo struct {} func (*echo) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { var body map[string]interface{} if err := rest.RequestBody(\u0026amp;body); err != nil { return rest.Respond(http.StatusBadRequest, err) } return rest.Respond(http.StatusOK, body) }  APIs Define APIs on services by calling the API() method on a service builder. Define the origin API on a domain by calling the Origin() method on a domain builder. In the root domain, use the microlith.Origin() function.\nIn the builder, you can add Head(), Get(), Post(), Put(), and Delete() endpoints and define Scope()s. The HTTP methods take a unique endpoint name, an Endpoint Lambda, and an optional output Endpoint argument.\nvar echoEndpoint *rest.Endpoint service.API(func(api *rest.APIBuilder) { api.Post(\u0026quot;echo\u0026quot;, new(echo), \u0026amp;echoEndpoint) })  The HTTP methods take an optional builder to define the Query() parameters and request Header()s, as well as the Response()s and response Header()s.\nvar listOrdersEndpoint *rest.Endpoint service.API(func(api *rest.APIBuilder) { api.Get(\u0026quot;list-orders\u0026quot;, new(listOrders), \u0026amp;listOrdersEndpoint, func(endpoint *rest.EndpointBuilder) { endpoint.Query(\u0026quot;page\u0026quot;, false) endpoint.Query(\u0026quot;limit\u0026quot;, false) endpoint.Header(\u0026quot;Authorization\u0026quot;, true) endpoint.Response(http.StatusOK, func(response *rest.ResponseBuilder) { response.Header(\u0026quot;X-Next-Page\u0026quot;, false) }) }) })  In Lambda functions, you can Call() the endpoint, passing an optional request body. The returned values are the same values returned by http.Client. You can decode the ResponseBody() as JSON, or you can get the ErrorResponse() if an error was passed to Respond().\nresp, err := echoEndpoint.Call(ctx, map[string]interface{}{\u0026quot;Hello\u0026quot;: \u0026quot;World\u0026quot;}) if err != nil { // ... } switch resp.StatusCode { case http.StatusOK: response := make(map[string]interface{}) if err := rest.ResponseBody(resp, \u0026amp;response); err != nil { // ... } fmt.Printf(\u0026quot;Response: %#v\\n\u0026quot;, response) default: err := rest.ErrorResponse(resp, nil) fmt.Printf(\u0026quot;Error: %s\\n\u0026quot;, err) }  You can use an optional builder to set the Query() and Path() parameters and request Header()s.\nresp, err := listOrdersEndpoint.Call(ctx, nil, func(request *rest.RequestBuilder) { request.Query(\u0026quot;page\u0026quot;, \u0026quot;2\u0026quot;) request.Query(\u0026quot;limit\u0026quot;, \u0026quot;10\u0026quot;) request.Header(\u0026quot;Authorization\u0026quot;, \u0026quot;\u0026lt;oauth-token\u0026gt;\u0026quot;) })  Scopes Scopes are HTTP paths. They can be multi-segment and contain path parameters in the form \u0026ldquo;{parameter-name}\u0026rdquo;. Scopes are created by calling Scope() on an API builder. Scopes can be nested within other scopes by calling Scope() on a scope builder.\nservice.API(func(api *rest.APIBuilder) { api.Scope(\u0026quot;/orders\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;list-orders\u0026quot;, new(listOrders), nil) scope.Post(\u0026quot;create-order\u0026quot;, new(createOrder), nil) scope.Scope(\u0026quot;/{order-id}\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;get-order\u0026quot;, new(getOrder), nil) scope.Put(\u0026quot;update-order\u0026quot;, new(updateOrder), nil) scope.Delete(\u0026quot;delete-order\u0026quot;, new(deleteOrder), nil) }) }) })  Query() parameters, request Header()s, and Response()s can be defined on a scope and will be inherited by all endpoints in that scope and all nested scopes. Inherited values can be overridden in individual endpoints or nested scopes.\nservice.API(func(api *rest.APIBuilder) { api.Scope(\u0026quot;/orders\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Header(\u0026quot;Authorization\u0026quot;, true) scope.Response(http.StatusInternalServerError) scope.Get(\u0026quot;list-orders\u0026quot;, new(listOrders), nil, func(endpoint *rest.EndpointBuilder) { endpoint.Header(\u0026quot;Authorization\u0026quot;, false) endpoint.Response(http.StatusOK, func(response *rest.ResponseBuilder) { response.Header(\u0026quot;X-Next-Page\u0026quot;, false) }) }) scope.Post(\u0026quot;create-order\u0026quot;, new(createOrder), nil, func(endpoint *rest.EndpointBuilder) { endpoint.Response(http.StatusCreated) endpoint.Response(http.StatusBadRequest) }) scope.Scope(\u0026quot;/{order-id}\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Response(http.StatusOK) scope.Response(http.StatusBadRequest) scope.Response(http.StatusNotFound) scope.Get(\u0026quot;get-order\u0026quot;, new(getOrder), nil) scope.Put(\u0026quot;update-order\u0026quot;, new(updateOrder), nil) scope.Delete(\u0026quot;delete-order\u0026quot;, new(deleteOrder), nil) }) }) })  "
},
{
	"uri": "http://microlith-framework.com/tutorial/root/",
	"title": "Hello, World!",
	"tags": [],
	"description": "",
	"content": " To start, we will add a single \u0026ldquo;Hello, world!\u0026rdquo; endpoint to our application and redeploy. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level microlith package.\nThe Endpoint First, we will create an endpoint Lambda function. To create the Lambda, implement the Handler interface. The endpoint uses the Respond() helper to return a 200 response code and the string \u0026ldquo;Hello, world!\u0026rdquo; This helper automatically encodes the response body as JSON.\ntype helloWorld struct {} func (endpoint *helloWorld) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Hello, world!\u0026quot;) }  The Origin Next, we will add the endpoint to the origin API.\nUse the microlith.Origin() function to define the root domain\u0026rsquo;s origin. Use the Swagger-based builder DSL to define the REST API. Endpoints are defined using methods named after HTTP verbs (Get(), Post(), etc.) Each endpoint has a unique endpoint name and a Lambda.\nWe\u0026rsquo;ll name our endpoint \u0026ldquo;hello-world\u0026rdquo; and mount it at \u0026ldquo;GET /\u0026rdquo;. We\u0026rsquo;ll use an instance of the Lambda we just wrote as our endpoint Lambda.\nfunc init() { microlith.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;hello-world\u0026quot;, new(helloWorld), nil) }) }  Ship It That\u0026rsquo;s all there is to adding an endpoint. Now you are ready to deploy your app:\ngit add . git commit -m \u0026quot;Added my first endpoint\u0026quot; git push origin master  If you receive a \u0026ldquo;403\u0026rdquo; when pushing to CodeCommit on Mac OS X, the credentials stored in the Keychain have expired. You will need to delete them to push again, as documented in Step 3 here.\n Once your application has deployed, you can make requests against your endpoint:\ncurl https://tutorial.my-domain.com/  You should receive a response of \u0026ldquo;Hello, world!\u0026rdquo;\nFreshly deployed Lambdas perform a cold start when the first request is received. When manual testing, you application may return a error until the Lambdas warm up. If it does retry the request a couple of times until it returns the expected response.\n "
},
{
	"uri": "http://microlith-framework.com/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Resources Briefly introduces each of the resources available to construct services. For complete documentation, refer to the GoDocs.\n"
},
{
	"uri": "http://microlith-framework.com/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": " Examples "
},
{
	"uri": "http://microlith-framework.com/intro/package/",
	"title": "Package",
	"tags": [],
	"description": "",
	"content": "With your tree built, there\u0026rsquo;s one last API to learn. And it\u0026rsquo;s the easiest of them all.\nfunc main() { microlith.Main() }  That\u0026rsquo;s it. Build your app like any other Go executable.\ngo install github.com/go-microlith/introduction.com  "
},
{
	"uri": "http://microlith-framework.com/resources/cron/",
	"title": "Schedued Jobs",
	"tags": [],
	"description": "",
	"content": "Jobs are Lambda functions that are triggered on a schedule. Create a Job Lambda by implementing the Job interface.\ntype purgeCache struct {} func (*purgeCache) Run(ctx context.Context, evt events.CloudWatchEvent) error { // ... }  Register the job by calling the Job() method on a service builder, giving it a unique job name, a schedule, and a Job Lambda. The schedule can be a simple time interval or a complex calendar, both expressed using CloudWatch Schedule Expressions.\nservice.Job(\u0026quot;purge-cache\u0026quot;, \u0026quot;rate(15 minutes)\u0026quot;, new(purgeCache))  "
},
{
	"uri": "http://microlith-framework.com/tutorial/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Although all external traffic goes through a domain\u0026rsquo;s origin API, the origin does not itself implement business logic. It makes calls on services and creates a response for the user.\nLet\u0026rsquo;s show how this works by refactoring our root domain into services. We\u0026rsquo;ll create a Word service that returns a fixed word. Then we\u0026rsquo;ll create two instances of that service, one returning \u0026ldquo;hello\u0026rdquo; and one returning \u0026ldquo;world\u0026rdquo;, and register them with our domain. Finally, we\u0026rsquo;ll refactor our origin endpoint to call those services and build the \u0026ldquo;Hello, world!\u0026rdquo; response.\nThe Word Service Microlith services are objects which implement the Service interface. The service object\u0026rsquo;s public methods are client methods that call the service\u0026rsquo;s endpoints.\nWe\u0026rsquo;ll create a Word service that returns a fixed word. It will have an endpoint which returns the word and a public method to call the endpoint.\ntype Word struct { word string endpoint *rest.Endpoint } func NewWord(word string) *Word { return \u0026amp;Word{word} } func (word *Word) Build(service *tld.ServiceBuilder) { // TODO } func (word *Word) Word(ctx context.Context) (string, error) { // TODO }  The \u0026ldquo;word\u0026rdquo; Endpoint The service has one endpoint. It simply returns a 200 OK with the word as JSON.\nCreate the Lambda just like the \u0026ldquo;hello-world\u0026rdquo; Lambda in the root domain. We\u0026rsquo;ll pass the word as an argument to the constructor.\ntype word struct { word string } func newWord(word string) rest.Handler { return \u0026amp;word{word} } func (endpoint *word) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, endpoint.word) }  Use the API() method on the service builder to add endpoints to the service\u0026rsquo;s API. This method behaves just like the microlith.Origin() function in the origin.\nIn services and subdomains, we will pass an Endpoint value as the third argument to the HTTP methods. This argument will be populated with an object we can use it to make calls on the endpoint.\nfunc (word *Word) Build(service *tld.ServiceBuilder) { service.API(func(api *rest.APIBuilder) { api.Get(\u0026quot;word\u0026quot;, newWord(word.word), \u0026amp;word.endpoint) }) }  The Word() Method Microlith services are regular Go objects. Their public methods are the service\u0026rsquo;s client, and are called from other Lambdas. The Word() method on our service object will call the \u0026ldquo;word\u0026rdquo; endpoint on our service.\nIn the Word() method, use the endpoint object to Call() the \u0026ldquo;word\u0026rdquo; endpoint. The returned value is a standard http.Response. Microlith provides ResponseBody() to parse a JSON response and ErrorResponse() to parse an error response.\nfunc (word *Word) Word(ctx context.Context) (string, error) { resp, err := word.endpoint.Call(ctx, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  The Root Domain Next, we need to update the root domain to use our new service.\nWe will create two instances of the Word service, one returning \u0026ldquo;hello\u0026rdquo; and the other \u0026ldquo;world\u0026rdquo;. Then we will call those services from our \u0026ldquo;hello-world\u0026rdquo; endpoint to construct the \u0026ldquo;Hello, world!\u0026rdquo; response.\nService Instances First, create the instances of the service. Register them with your root domain using the microlith.Service() function.\nfunc init() { // ... Same as before ... helloSvc := NewWord(\u0026quot;hello\u0026quot;) worldSvc := NewWord(\u0026quot;world\u0026quot;) microlith.Service(\u0026quot;hello\u0026quot;, helloSvc) microlith.Service(\u0026quot;world\u0026quot;, worldSvc) }  The \u0026ldquo;hello-world\u0026rdquo; Endpoint We need to refactor our \u0026ldquo;hello-world\u0026rdquo; endpoint to call both the \u0026ldquo;hello\u0026rdquo; service and the \u0026ldquo;world\u0026rdquo; service. To do that, it needs references to the services. Create a constructor that takes the services and stores them in instance variables.\ntype helloWorld struct { helloSvc *Word worldSvc *Word } func newHelloWorld(hello, world *Word) rest.Handler { return \u0026amp;helloWorld{ helloSvc: hello, worldSvc: world, } }  Next, use the client methods on your service objects to call the services. Use the returned values to construct the response to the user.\nfunc (endpoint *helloWorld) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { hello, err := endpoint.helloSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } world, err := endpoint.worldSvc.Word(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } helloWorld := fmt.Sprintf(\u0026quot;%s, %s!\u0026quot;, strings.Title(hello), world) return rest.Respond(http.StatusOK, helloWorld) }  The Origin Finally, we need to update the origin to use the new constructor.\nfunc init() { microlith.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;hello-world\u0026quot;, newHelloWorld(helloSvc, worldSvc), nil) }) }  Ship It There. Factored into services. You should be ready to deploy.\ngit add . git commit -m \u0026quot;Factored into services\u0026quot; git push origin master  Once deployed, you can make requests against your domain. You should see the same response as before.\ncurl https://tutorial.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/tutorial/channels/",
	"title": "Channels",
	"tags": [],
	"description": "",
	"content": " The origin calls on services to implement business logic, but services within a domain cannot call each other. Instead, services communicate asynchronously using shared broadcast channels.\nWhen events occur, such as a user deleting a business object, services publish those events to a channel. Services process events on the channel and update themselves according to their own internal business logic, such as purging their related objects.\nLet\u0026rsquo;s create a channel for request events. The \u0026ldquo;hello-world\u0026rdquo; endpoint in the origin will publish an event every time a request is made against it. The Word service will process the events and write them out to the logs.\nThe Requests Channel Use the microlith.Channel() function to create a channel.\nfunc init() { requests := microlith.Channel(\u0026quot;requests\u0026quot;) // ... Same as before ... }  Let\u0026rsquo;s alsoo create an event type to represent requests. We will simply record when the request occurred.\ntype RequestEvent struct { At time.Time } func NewRequestEvent() *RequestEvent { return \u0026amp;RequestEvent{time.Now()} }  The Word Service The Word service needs to be refactored to write the request events to the logs.\nFirst, update the constructor for the Word service so that it takes the channel as an argument. The value will be needed in the builder, so we place it in an instance variable.\ntype Word struct { // ... Same as before ... requests *strm.Stream } func NewWord(word string, requests *strm.Stream) *Word { return \u0026amp;Word{ word: word, requests: requests, } }  The \u0026ldquo;log-requests\u0026rdquo; Processor Next, we will create a processor Lambda function and hook it up to the channel. To create the Lambda, implement the Processor interface. Events are passed to the Lambda as batches. Create a Scanner to iterate over the batch.\nAll console output from Lambdas goes to CloudWatch Logs. All we need to do in the Lambda is iterate over the batch and log each request.\ntype requestLogger struct {} func (processor *requestLogger) Process(ctx context.Context, evt events.KinesisEvent) error { scanner := strm.NewScanner(evt) for scanner.Next() { partitionKey := \u0026quot;\u0026quot; request := new(RequestEvent) if err := scanner.Scan(\u0026amp;partitionKey, request); err != nil { return err } log.Printf(\u0026quot;Request made at %s\u0026quot;, request.At.Format(time.RFC3339Nano)) } return nil }  Use the Processor() method on the service builder to process events from channels. Pass a builder function and Process() individual channels. Each channel needs a StartingPosition within the stream.\nfunc (word *Word) Build(service *tld.ServiceBuilder) { // ... Same as before ... service.Processor(\u0026quot;log-requests\u0026quot;, new(requestLogger), func(processor *strm.ProcessorBuilder) { processor.Process(word.requests, strm.StartingPositionTrimHorizon) }) }  The Root Domain Now that the service is updated to subscribe to the channel, we need to provide the channel to the instances of the service and start publishing events from the \u0026ldquo;hello-world\u0026rdquo; endpoint.\nFirst, use the new constructor for the Word service to pass the channel to the service instances.\nfunc init() { // ... Same as before ... helloSvc := NewWord(\u0026quot;hello\u0026quot;, requests) worldSvc := NewWord(\u0026quot;world\u0026quot;, requests) // ... Same as before ... )  Publish Events We need to update the \u0026ldquo;hello-world\u0026rdquo; handler to publish request events. First, update the constructor to take the channel as an argument and place it in an instance variable.\ntype helloWorld struct { // ... Same as before ... requests *strm.Stream } func newHelloWorld(hello, world *Word, requests *strm.Stream) rest.Handler { return \u0026amp;helloWorld{ helloSvc: hello, worldSvc: world, requests: requests, } }  Next, Publish() events in the channel. This method automatically serializes and batches the messages. Defer a call to Flush() to ensure that any batched messages are sent.\nfunc (endpoint *helloWorld) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { defer endpoint.requests.Flush(ctx) if err := endpoint.requests.Publish(ctx, \u0026quot;partition-key\u0026quot;, NewRequestEvent()); err != nil { return rest.Respond(http.StatusInternalServerError, err) } // ... Same as before ... }  Finally, update your origin to use the new constructor for the \u0026ldquo;hello-world\u0026rdquo; endpoint.\nfunc init() { // ... Same as before ... microlith.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;hello-world\u0026quot;, newHelloWorld(helloSvc, worldSvc, requests), nil) }) }  Ship It Now your services will process an event every time a request is made against the \u0026ldquo;hello-world\u0026rdquo; endpoint. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Added a channel\u0026quot; git push origin master  Make a request against your application and the processors will soon emit a message to their CloudWatch logs.\ncurl https://tutorial.my-domain.com/  "
},
{
	"uri": "http://microlith-framework.com/resources/inst/",
	"title": "Log Readers",
	"tags": [],
	"description": "",
	"content": "Readers are Lambda functions that read the logs of other Lambda functions. All console output from Lambdas is captured as CloudWatch Logs. Readers are triggered on log messages. Create a Reader Lambda by implementing the Reader interface.\ntype onError struct {} func (*onError) Read(ctx context.Context, evt events.CloudwatchLogsEvent) error { data, err := evt.AWSLogs.Parse() if err != nil { return err } for _, logEvent := range data.LogEvents { fmt.Printf(\u0026quot;Error found in log group %q: %s\u0026quot;, evt.LogGroup, logEvent.Message) } return nil }  Register the reader by calling the Reader() method on a service builder, passing a unique reader name and a Reader Lambda. Use the builder to Read() a Lambda\u0026rsquo;s logs. You can pass a non-blank filter to reduce log volume.\nservice.Reader(\u0026quot;on-errors\u0026quot;, new(onError), func(reader *inst.ReaderBuilder) { reader.Read(imageAdded, \u0026quot;s3 error\u0026quot;) reader.Read(userSignedUp, \u0026quot;kinesis error\u0026quot;) reader.Read(albumAdded, \u0026quot;dynamodb error\u0026quot;) })  "
},
{
	"uri": "http://microlith-framework.com/intro/ship/",
	"title": "Ship",
	"tags": [],
	"description": "",
	"content": "Deployment is simple. Your app provisions its own miniature Heroku in AWS with a single command.\nintroduction.com instance bootstrap --import-path github.com/go-microlith/introduction.com  You just push. Microlith takes care of the rest.\ngit add . git commit -m \u0026quot;My changes\u0026quot; git push origin master  "
},
{
	"uri": "http://microlith-framework.com/cleanup/",
	"title": "Teardown Instructions",
	"tags": [],
	"description": "",
	"content": " The teardown for an application is a straightforward manual procedure in the AWS Console.\nThe bootstrap process creates two main CloudFormation stacks. A bootstrap stack and a production stack. These stacks are named after the application, such as tutorial-com, and tutorial-com-prod. The production stack also has multiple nested stacks. The stacks must be deleted in the correct order, and user data in a stack must be manually deleted before a stack can be torn down.\nProcess  If using CodeCommit on Mac OS X, delete the CodeCommit repository key from Keychain as described in step 3 here. Empty any buckets in the production stack and any of its nested stacks. Delete the root production stack. Its nested stacks will be torn down automatically. Wait for the production stack to fully delete (i.e., disappear from the CloudFormation console.) Empty the bootstrap bucket in the bootstrap stack. Disable termination protection on the bootstrap stack. Delete the bootstrap stack.  If you delete the bootstrap stack before the production stack has been fully deleted, it will delete the IAM role and you will be unable to tear down the production stack. If this happens, you must manually recreate the deleted \u0026ldquo;DeployRole\u0026rdquo; exactly (including the generated name) to tear down the production stack. Termination protection is enabled on the bootstrap stack to prevent this.\n "
},
{
	"uri": "http://microlith-framework.com/intro/fin/",
	"title": "Fin.",
	"tags": [],
	"description": "",
	"content": "That\u0026rsquo;s it. That\u0026rsquo;s all there is to Microlith.\nNow let\u0026rsquo;s build something. Set up your prerequisites and try the tutorial.\nYou can jump ahead and read about the resources Microlith supports. Or you can check out the example applications or the GoDocs.\nHave questions? Encounter problems? Want to keep up to date? Join the mailing list: go-serverless@microlith-framework.com\n"
},
{
	"uri": "http://microlith-framework.com/tutorial/subdomains/",
	"title": "Subdomains",
	"tags": [],
	"description": "",
	"content": " The application has a root domain and a set of subdomains, and it routes traffic to them using DNS. Each domain\u0026rsquo;s origin is mounted under a single DNS name. The root domain is mounted at the base DNS name you specified during the bootstrap process. The subdomains are named using subdomain prefixes, and are mounted as subdomains of the base DNS name.\nLet\u0026rsquo;s create a domain named \u0026ldquo;sub\u0026rdquo; that mirrors the root domain. The origin will have one endpoint that returns \u0026ldquo;Hello, subdomain world!\u0026rdquo;. Like the root domain, it have a \u0026ldquo;hello\u0026rdquo; and a \u0026ldquo;world\u0026rdquo; service and have a channel for request events.\nThe Sub Domain Microlith domains are objects which implement the Domain interface. Like a service, a domain built with a builder DSL and its public methods call endpoints on the domain.\nWe\u0026rsquo;ll create a Sub object to represent the domain. All of top-level vars in the root domain are instance variables in the Sub domain.\ntype Sub struct { helloSvc *Word worldSvc *Word requests *strm.Stream endpoint *rest.Endpoint } func NewSub() *Sub { return new(Sub) } func (sub *Sub) Build(domain *tld.DomainBuilder) { // TODO } func (sub *Sub) HelloSubdomainWorld(ctx context.Context) (string, error) { // TODO }  The \u0026ldquo;requests\u0026rdquo; Channel We are going to reuse our Word service in the domain, and that requires a channel with request events. Use the Channel() method on the domain builder to create a channel.\nfunc (sub *Sub) Build(domain *tld.Domain) { sub.channel = domain.Channel(\u0026quot;requests\u0026quot;) }  The \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo; Services Like in the root domain, we will create two instances of the Word service, one returning \u0026ldquo;hello\u0026rdquo; and one returning \u0026ldquo;world\u0026rdquo;. Register the instances with the domain using the Service() method on the domain builder.\nfunc (sub *Sub) Build(domain *tld.DomainBuilder) { // ... Same as before ... sub.helloSvc = NewWord(\u0026quot;hello\u0026quot;, sub.requests) sub.worldSvc = NewWord(\u0026quot;world\u0026quot;, sub.requests) domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) domain.Service(\u0026quot;world\u0026quot;, sub.worldSvc) }  The \u0026ldquo;hello-subdomain-world\u0026rdquo; Endpoint Next, we need to add a \u0026ldquo;hello-subdomain-world\u0026rdquo; endpoint to the domain\u0026rsquo;s origin. This endpoint needs to call the \u0026ldquo;hello\u0026rdquo; and \u0026ldquo;world\u0026rdquo; services and construct the \u0026ldquo;Hello, subdomain world!\u0026rdquo; response.\nThe only difference between this endpoint and the \u0026ldquo;hello-world\u0026rdquo; endpoint is the response. Let\u0026rsquo;s just extend the existing Lambda to support this. First, we\u0026rsquo;ll add an instance variable to hold the infix string and extend the constructor to populate it.\ntype helloWorld struct { // ... Same as before ... infix string } func newHelloWorld(hello, world *Word, requests *strm.Stream, infix string) rest.Handler { return \u0026amp;helloSubdomainWorld{ helloSvc: hello, worldSvc: world, requests: requests, infix: infix, } }  And then we\u0026rsquo;ll refactor the endpoint to include the infix string if it\u0026rsquo;s not blank.\nfunc (endpoint *helloWorld) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { // ... Same as before ... helloWorld := fmt.Sprintf(\u0026quot;%s, %s!\u0026quot;, strings.Title(hello), world) if endpoint.infix != \u0026quot;\u0026quot; { helloWorld = fmt.Sprintf(\u0026quot;%s, %s %s!\u0026quot;, string.Title(hello), endpoint.infix, world) } // ... Same as before ... }  The domain builder has an Origin() method to define the API with a \u0026ldquo;hello-subdomain-world\u0026rdquo; endpoint. We\u0026rsquo;ll create an instance of the Lambda with \u0026ldquo;subdomain\u0026rdquo; infix as our handler, and we\u0026rsquo;ll capture the endpoint variable so we can create the client method.\nfunc (sub *Sub) Build(domain *tld.DomainBuilder) { // ... Same as before ... domain.Origin(func(api *rest.APIBuilder) { scope.Get(\u0026quot;hello-subdomain-world\u0026quot;, newHelloWorld(sub.helloSvc, sub.worldSvc, sub.requests, \u0026quot;subdomain\u0026quot;), \u0026amp;sub.endpoint) }) }  The HelloSubdomainWorld() Method The HelloSubdomainWorld() method on the domain object it the client method. It uses the captured endpoint object to call the \u0026ldquo;hello-subdomain-world\u0026rdquo; endpoint on the service.\nfunc (sub *Sub) HelloSubdomainWorld(ctx context.Context) (string, error) { resp, err := sub.endpoint.Call(ctx, nil) if err != nil { return \u0026quot;\u0026quot;, err } switch resp.StatusCode { case http.StatusOK: msg := \u0026quot;\u0026quot; if err := rest.ResponseBody(resp, \u0026amp;msg); err != nil { return \u0026quot;\u0026quot;, err } return msg, nil default: err := rest.ErrorResponse(resp, nil) return \u0026quot;\u0026quot;, err } }  The Root Domain Now that we have the Sub domain, we can add it to the application. Subdomains are directly routable via their DNS name, but they can also be called by the root domain.\nWe\u0026rsquo;ll create an instance of the domain and register it with the application. Then we\u0026rsquo;ll add an endpoint to the root domain\u0026rsquo;s origin to call the subdomain.\nDomain Instance Use the microlith.Subdomain() function to register the domain with the application. Each domain is mounted under a unique subdomain prefix. We\u0026rsquo;ll simply use \u0026ldquo;sub\u0026rdquo;.\nfunc init() { // ... Same as before ... sub := NewSub() microlith.Subdomain(\u0026quot;sub\u0026quot;, sub) // ... Same as before ... }  The \u0026ldquo;proxy-to-subdomain\u0026rdquo; Endpoint The \u0026ldquo;proxy-to-subdomain\u0026rdquo; endpoint on the root origin will call the \u0026ldquo;hello-subdomain-world\u0026rdquo; endpoint on the \u0026ldquo;sub\u0026rdquo; domain.\nCreate a endpoint Lambda that takes the domain as an argument. In the function, call the HelloSubdomainWorld() method on the domain and return the response.\ntype subdomainProxy struct { sub *Sub } func newSubdomainProxy(sub *Sub) rest.Handler { return \u0026amp;subdomainProxy{sub} } func (endpoint *subdomainProxy) ServeREST(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { msg, err := endpoint.sub.HelloSubdomainWorld(ctx) if err != nil { return rest.Respond(http.StatusInternalServerError, err) } return rest.Respond(http.StatusOK, msg) }  We want to mount the endpoint at \u0026ldquo;GET /proxy/to/subdomain\u0026rdquo;. To create nested paths in an API, use the Scope() method. Within the builder, use the same HTTP method you use on the API builder.\nWhile we\u0026rsquo;re in the root origin, we need to fix it to use the updated constructor for the \u0026ldquo;hello-world\u0026rdquo; endpoint.\nfunc init() { // ... Same as before ... microlith.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;hello-world\u0026quot;, newHelloWorld(helloSvc, worldSvc, requests, \u0026quot;\u0026quot;), nil) api.Scope(\u0026quot;/proxy/to/subdomain\u0026quot;, func(scope *rest.ScopeBuilder) { scope.Get(\u0026quot;proxy-to-subdomain\u0026quot;, newSubdomainProxy(sub), nil) }) }) }  Ship It Now your app has a subdomain that mirrors the root domain. Deploy your app:\ngit add . git commit -m \u0026quot;Added a subdomain\u0026quot; git push origin master  Adding a subdomain causes Microlith to issue new SSL certificates. The contact for the validation domain will get another ACM certificate confirmation. The build pipeline will stall until the confirmation is completed.\n Now you can make requests against the subdomain either directly or via the proxy endpoint:\n# Direct request curl https://sub.tutorial.my-domain.com/ # Via the proxy endpoint curl https://tutorial.my-domain.com/proxy/to/subdomain  "
},
{
	"uri": "http://microlith-framework.com/tutorial/globals/",
	"title": "Globals",
	"tags": [],
	"description": "",
	"content": " The application has a special \u0026ldquo;pseudo-domain\u0026rdquo; called the globals. The globals are a set of services and channels that are shared between all domains. You can use them in any domain as if they were part of that domain.\nLet\u0026rsquo;s factor some shared logic out of our application by promoting the \u0026ldquo;world\u0026rdquo; service to a global service. Since the service relies on the requests channel, the channel will need to be promoted to a global channel. When we are done, both the root domain and the subdomain will each have their own \u0026ldquo;hello\u0026rdquo; service and will use the global \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel. Since the channel has become shared, all services will process request events from both the root and the subdomain origins.\nThe \u0026ldquo;word\u0026rdquo; Service and \u0026ldquo;request\u0026rdquo; Channel First, we need to promote the \u0026ldquo;world\u0026rdquo; service to a global service and the \u0026ldquo;requests\u0026rdquo; channel to a global channel. To promote the \u0026ldquo;world\u0026rdquo; service, register the service using the microlith.GlobalService() function. For the \u0026ldquo;requests\u0026rdquo; channel, create the channel with the microlith.GlobalChannel() function.\nfunc init() { requests := microlith.GlobalChannel(\u0026quot;requests\u0026quot;) // ... Same as before ... microlith.GlobalService(\u0026quot;world\u0026quot;, worldSvc) }  The Sub Domain The subdomain needs to get a reference to the global \u0026ldquo;words\u0026rdquo; service so it can call it, and a reference to the global \u0026ldquo;requests\u0026rdquo; channel so that it can construct the \u0026ldquo;hello\u0026rdquo; service and publish request events.\nThe subdomain constructor needs to take the \u0026ldquo;words\u0026rdquo; service and the \u0026ldquo;request\u0026rdquo; channel as arguments. They are stored in instance variables since they will be needed in Lambdas. We can also change the constructor to create the instance of the \u0026ldquo;hello\u0026rdquo; service since all of the arguments are now available.\nfunc NewSub(world *Word, requests *strm.Stream) *Sub { return \u0026amp;Sub{ helloSvc: NewWord(\u0026quot;hello\u0026quot;, requests), worldSvc: world, requests: requests, } }  The services and the channel no longer need to be instantiated in the builder. They are either passed into or instantiated in the constructor. The builder also no longer needs to register the \u0026ldquo;world\u0026rdquo; service, since it is global. The builder only needs to register the \u0026ldquo;hello\u0026rdquo; service created in the constructor.\nfunc (sub *Sub) Build(domain *tld.DomainBuilder) { domain.Service(\u0026quot;hello\u0026quot;, sub.helloSvc) // ... Same as before ... }  The Root Domain Finally, the instance of the subdomain needs to be passed the \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel when it is constructed.\nfunc init() { // ... Same as before ... sub := NewSub(worldSvc, requests) // ... Same as before ... }  Ship It Now, the \u0026ldquo;world\u0026rdquo; service and \u0026ldquo;requests\u0026rdquo; channel are no longer part of the root domain, but shared across all domains. Commit and push to deploy your changes.\ngit add . git commit -m \u0026quot;Promoted 'world' to a global service\u0026quot; git push origin master  Finally, call your endpoints to verify that your application functions as expected.\n# hello-world curl https://tutorial.my-domain.com/ # hello-subdomain-world curl https://sub.tutorial.my-domain.com/ # proxy-to-subdomain curl https://tutorial.my-domain.com/proxy/to/subdomain  "
},
{
	"uri": "http://microlith-framework.com/",
	"title": "Microlith",
	"tags": [],
	"description": "",
	"content": " Microlith Featherweight Serverless in Go\nfunc init() { microlith.Origin(func(api *rest.APIBuilder) { api.Get(\u0026quot;microlith\u0026quot;, rest.HandlerFunc(handler), nil) }) } func handler(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) { return rest.Respond(http.StatusOK, \u0026quot;Go Serverless\u0026quot;) } func main() { microlith.Main() }  "
},
{
	"uri": "http://microlith-framework.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://microlith-framework.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]