<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microlith</title>
    <link>http://example.org/</link>
    <description>Recent content on Microlith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 18:00:28 -0600</lastBuildDate>
    
	<atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tutorial</title>
      <link>http://example.org/examples/tutorial/</link>
      <pubDate>Thu, 25 Oct 2018 18:58:57 -0600</pubDate>
      
      <guid>http://example.org/examples/tutorial/</guid>
      <description>The complete code from the tutorial is available in the  tutorial.com repository.
Clone The repository should be cloned to the root of your Go workspace&amp;rsquo;s source tree, i.e. ${GOPATH}/src/tutorial.com.
# Clone the repo to the root of your Go workspace&#39;s source tree mkdir -p &amp;quot;${GOPATH}/src/tutorial.com&amp;quot; git clone https://github.com/go-microlith/tutorial.com &amp;quot;${GOPATH}/src/tutorial.com&amp;quot; # Microlith will recreate this rm -rf &amp;quot;${GOPATH}/src/tutorial.com/.git/&amp;quot; # Build the application go install tutorial.com  Bootstrap Assuming you own the domain name my-domain.</description>
    </item>
    
    <item>
      <title>Get Microlith</title>
      <link>http://example.org/bootstrap/go_get/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/go_get/</guid>
      <description>Microlith is a standard Go library. Just use &amp;ldquo;go get&amp;rdquo;:
go get gopkg.in/microlith.v0  Now you&amp;rsquo;re ready to create your first application.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://example.org/architecture/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/services/</guid>
      <description>Business logic for an application is factored into Services. A Service is a REST API, a set of resources, and a set of asynchronous actions.
Serverless Services follow an AWS::Serverless model, containing resources such as Buckets, Tables, and Streams along with Lambda functions to asynchronously react to events on those resources. All external access to the resources goes through endpoints on a REST API.
Scope All resources in the service are available to all Lambdas in the service, but services cannot access resources outside of the ones they declare nor other services.</description>
    </item>
    
    <item>
      <title>The Root Domain</title>
      <link>http://example.org/tutorial/root/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/root/</guid>
      <description>The root domain is the starting point for a Microlith application. It has a specialized API exposed via the top-level &amp;ldquo;microlith&amp;rdquo; package.
We will start by adding a &amp;ldquo;Hello, world!&amp;rdquo; endpoint to our application.
The Origin You add endpoints by defining an API with the microlith.Scope() function.
You must pass a unique name and a handler function for each defined endpoint. This function must match the signature of an API Gateway Lambda Function.</description>
    </item>
    
    <item>
      <title>Blog</title>
      <link>http://example.org/examples/blog/</link>
      <pubDate>Thu, 25 Oct 2018 18:58:57 -0600</pubDate>
      
      <guid>http://example.org/examples/blog/</guid>
      <description>A blogging application with social features is available in the  blog.com repository.
It provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (&amp;ldquo;Like&amp;rdquo;, &amp;ldquo;Love&amp;rdquo;, etc.) on both posts and comments.
Clone The repository should be cloned to the root of your Go workspace&amp;rsquo;s source tree, i.e. ${GOPATH}/src/blog.com:
# Clone the repo to the root of your Go workspace&#39;s source tree mkdir -p &amp;quot;${GOPATH}/src/blog.</description>
    </item>
    
    <item>
      <title>Domains</title>
      <link>http://example.org/architecture/domains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/domains/</guid>
      <description>Services are grouped into a Domain. A Domain is a REST API, a set of services, and set of channels.
Routing Domains route using REST. The API, called the Origin, handles all external traffic. It receives requests, makes calls on the services to collect state and perform business logic, and then constructs a response to the user.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://example.org/tutorial/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/services/</guid>
      <description>Services implement the business logic of your Microlith application. At the code level, a service is an object which implements the tld.ServiceBuilder interface.
Let&amp;rsquo;s refactor our domain into a pair of services: a &amp;ldquo;hello&amp;rdquo; and a &amp;ldquo;world&amp;rdquo; service. Then we&amp;rsquo;ll refactor our origin endpoint to call those services to build a response.
Create a Service We will create a &amp;ldquo;word&amp;rdquo; service that returns a fixed word. The word service will have one endpoint that responds with the word as JSON.</description>
    </item>
    
    <item>
      <title>Your First Application</title>
      <link>http://example.org/bootstrap/create/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/create/</guid>
      <description>Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com.
Create an Application To create an application, create an executable in ${GOPATH}/src/example.com/main.go and call microlith.Main():
package main import ( microlith &amp;quot;gopkg.in/microlith.v0&amp;quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, &amp;ldquo;example.com&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://example.org/architecture/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/channels/</guid>
      <description>Services need to communicate, but cannot call endpoints on each other. To communicate between services, Microlith provides broadcast channels.
Any service can publish events onto channels it has references to. When a service publishes an event on a channel, all subscribed processors in all services receive that event.</description>
    </item>
    
    <item>
      <title>Resources</title>
      <link>http://example.org/tutorial/resources/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/resources/</guid>
      <description>Each service is an AWS::Serverless service composed of resources and asynchronous actions. You add resources and actions via the service builder in your Build() method. Microlith supports a subset of the full AWS::Serverless specification. You can find documentation on the supported resources and actions in the GoDocs:
 REST APIs S3 Buckets Kinesis Streams DynamoDB Tables Cron Jobs CloudWatch Log Readers  </description>
    </item>
    
    <item>
      <title>Route53</title>
      <link>http://example.org/bootstrap/route53/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/route53/</guid>
      <description>Microlith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once set up, a domain name can be reused for multiple Microlith applications.
You will need the Domain Name and the Hosted Zone ID to bootstrap your application. For the remainder of the documentation, we will assume you own my-domain.com in hosted zone Z1234567890.
 Domain Name You will need a domain name hosted in Route53.</description>
    </item>
    
    <item>
      <title>Application</title>
      <link>http://example.org/architecture/application/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/application/</guid>
      <description>An Application is the top-level container in a Microlith app. An application is a root domain, a set of named subdomains, and a set of global services and channels.
Routing An Application routes using DNS. The root domain is mounted under the top-level DNS name specified in the bootstrap process. All subdomains are mounted relative to the root domain.</description>
    </item>
    
    <item>
      <title>Bootstrap Your Application</title>
      <link>http://example.org/bootstrap/bootstrap/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/bootstrap/</guid>
      <description>The bootstrap process will host for your application in AWS.
This includes a Git repository for your source code and a continuous deployment pipeline with test and production environments for your application. It will then initialize a git repository in your local source tree, create an initial commit and push, and wait for a full build and deploy to go green.
The process will take several minutes for the initial deploy.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://example.org/tutorial/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/channels/</guid>
      <description>Channels are created by calling either the microlith.Channel() function to create a channel in the root domain, or by calling the microlith.Channel() method on a domain builder to create a channel in a subdomain. The returned reference can then be passed to a service so the service can interact with the channel.
Let&amp;rsquo;s create a channel that logs an event when a request is made against the &amp;ldquo;hello-world&amp;rdquo; endpoint in the Origin.</description>
    </item>
    
    <item>
      <title>Done</title>
      <link>http://example.org/bootstrap/done/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/done/</guid>
      <description>Once the build completes and deploys, your application has been bootstrapped.
Call Your Application You can validate that it is running by making a HTTP request against your test and production instances. You should receive a &amp;ldquo;Missing authentication token&amp;rdquo; message since no endpoints are defined.
curl -v https://test.my-domain.com/ curl -v https://prod.my-domain.com/  Deploy Your Application From now on, git push origin master deploys your application:
git add . git commit -m &amp;quot;My changes&amp;quot; git push origin master  If you receive a &amp;ldquo;403&amp;rdquo; when trying to push on Mac OS X, the credentials stored in the Keychain have expired.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://example.org/architecture/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/globals/</guid>
      <description>Some business logic needs to be shared between multiple domains, but services and subdomains cannot access each other. To share logic across the entire application, Microlith provides Global services and channels.
Services Global services share business logic across domains. They can be called by all services and origins.
Channels Global channels broadcast messages among all services and origins.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://example.org/tutorial/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/globals/</guid>
      <description>Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.
Global channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.
Let&amp;rsquo;s promote the &amp;ldquo;world&amp;rdquo; service to a global service and the &amp;ldquo;requests&amp;rdquo; channel to a global channel.
Promote the World Service To promote the &amp;ldquo;world&amp;rdquo; service, we need to use the microlith.</description>
    </item>
    
    <item>
      <title>Subdomains</title>
      <link>http://example.org/tutorial/subdomains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/subdomains/</guid>
      <description>Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.
Let&amp;rsquo;s create a subdomain named &amp;ldquo;sub.domain&amp;rdquo; that returns &amp;ldquo;Hello, subdomain world!&amp;rdquo;. It will have a &amp;ldquo;hello&amp;rdquo; service and use the global &amp;ldquo;world&amp;rdquo; service and &amp;ldquo;requests&amp;rdquo; channel. The subdomain&amp;rsquo;s origin will have an endpoint that calls these services and constructs the response.</description>
    </item>
    
  </channel>
</rss>