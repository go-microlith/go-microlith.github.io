<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microlith</title>
    <link>http://example.org/</link>
    <description>Recent content on Microlith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 18:00:28 -0600</lastBuildDate>
    
	<atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Get Microlith</title>
      <link>http://example.org/bootstrap/go_get/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/go_get/</guid>
      <description>Use go get to fetch Microlith:
go get -u gopkg.in/microlith.v0  </description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://example.org/architecture/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/services/</guid>
      <description>Business logic for an application is factored into Services. A Service is a REST API, a set of resources, and a set of asynchronous actions.
Services follow an AWS::Serverless model, containing resources such as Buckets, Tables, and Streams along with Lambda functions to asynchronously react to events on those resources. All external access to the resources goes through endpoints on a REST API.
All resources in the service are available to all Lambdas in the service, but services cannot access resources outside of the ones they declare nor other services.</description>
    </item>
    
    <item>
      <title>The Root Domain</title>
      <link>http://example.org/tutorial/root/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/root/</guid>
      <description>The root domain is the starting point for a Microlith application. It has a specialized API exposed via the top-level microlith package.
The Origin Start by creating a single endpoint on the origin of your root domain. This endpoint responds to GET / with a 200 OK and a response body of &amp;quot;Hello, world!&amp;quot;.
You add endpoints by defining an API with the microlith.Scope() function. You must pass a unique name and a handler function for each defined endpoint.</description>
    </item>
    
    <item>
      <title>Create An Application</title>
      <link>http://example.org/bootstrap/create/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/create/</guid>
      <description>Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com. To create an application, create an executable in ${GOPATH}/src/example.com/main.go that calls microlith.Main().
package main import ( microlith &amp;quot;gopkg.in/microlith.v0&amp;quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, example.com.
The import path of the source code is also significant to Microlith.</description>
    </item>
    
    <item>
      <title>Domains</title>
      <link>http://example.org/architecture/domains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/domains/</guid>
      <description>Services are grouped into a Domain. A Domain is a REST API, a set of services, and set of channels.
Domains route using REST. The API, called the Origin, handles all external traffic. It receives requests, makes calls on the services to collect state and perform business logic, and then constructs a response to the user.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://example.org/tutorial/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/services/</guid>
      <description>Services implement the business logic of your Microlith application. At the code level, a service is an object which implements the tld.ServiceBuilder interface.
Let&amp;rsquo;s refactor our domain into a pair of services: a hello and a world service. Then we&amp;rsquo;ll refactor our origin endpoint to call those services to build a response.
Create a Service We will create a word service that returns a fixed word. The word service will have one endpoint that responds to GET / with a 200 OK and the word as JSON.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://example.org/architecture/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/channels/</guid>
      <description>To communicate between services, you can create Channels. Channels provide asynchronous broadcast messaging to all services in a domain.
Any service can publish events onto channels it has references to. When a service publishes an event on a channel, all subscribed processors in all services receive that event.</description>
    </item>
    
    <item>
      <title>Resources</title>
      <link>http://example.org/tutorial/resources/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/resources/</guid>
      <description>Each service is an AWS::Serverless service composed of resources and asynchronous actions. You add resources and actions via the service builder in your Build() method. Microlith supports a subset of the full AWS::Serverless specification. You can find documentation on the supported resources and actions in the GoDocs:
 REST APIs S3 Buckets Kinesis Streams DynamoDB Tables Cron Jobs CloudWatch Log Readers  </description>
    </item>
    
    <item>
      <title>Route53</title>
      <link>http://example.org/bootstrap/route53/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/route53/</guid>
      <description>Microlith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once set up, a domain name can be reused for multiple Microlith applications.
Domain Name You will need a domain name hosted in Route53. If you have an existing domain, it can be reused. Microlith will not alter the settings of the domain name, only manage a set of subdomain A records for each application.</description>
    </item>
    
    <item>
      <title>Application</title>
      <link>http://example.org/architecture/application/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/application/</guid>
      <description>An Application is the top-level container in a Microlith app. An application is a root domain, a set of named subdomains, and a set of global services and channels.
An Application routes using DNS. The root domain is mounted under the top-level DNS name specified in the bootstrap process. All subdomains are mounted relative to the root domain.</description>
    </item>
    
    <item>
      <title>Bootstrap Your Application</title>
      <link>http://example.org/bootstrap/bootstrap/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/bootstrap/</guid>
      <description>The bootstrap process will host for your application in AWS. This includes a Git repository for your source code and a continuous deployment pipeline with test and production environments for your application. It will then initialize a git repository in your local source tree, create an initial commit and push, and wait for a full build and deploy to go green.
The process will take several minutes for the initial deploy.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://example.org/tutorial/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/channels/</guid>
      <description>Services need to communicate, but cannot Call() each other. To communicate between services, Microlith provides broadcast channels. A Channel is a Stream that is shared between all services in a domain. It can be published to and processed from just like a stream.
Channels are created by calling either the microlith.Channel() function to create a channel in the root domain, or by calling the Channel() method on a domain builder to create a channel in a subdomain.</description>
    </item>
    
    <item>
      <title>Done</title>
      <link>http://example.org/bootstrap/done/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/bootstrap/done/</guid>
      <description>Once the build completes and deploys, your application has been bootstrapped.
You can validate that it is running by making a HTTP request against your test and production instances. You should receive a &amp;ldquo;Missing authentication token&amp;rdquo; message since no endpoints are defined.
curl -v https://test.my-domain.com/ curl -v https://prod.my-domain.com/  From now on, git push origin master deploys your application:
git add . git commit -m &amp;quot;My changes&amp;quot; git push origin master  If you receive a 403 when trying to push on Mac OS X, the credentials stored in the Keychain have expired.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://example.org/architecture/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/architecture/globals/</guid>
      <description>Global services share business logic across domains. They can be called by all services and origins.
Global channels broadcast messages among all services and origins.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://example.org/tutorial/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/globals/</guid>
      <description>Some business logic needs to be shared between multiple domains, but services and subdomains cannot access each other. To share logic across the entire application, Microlith provides Global services and channels.
Global services are addressable by all services and origins in any domain. Global services are created by calling the microlith.GlobalService() function with a tld.ServiceBuilder. The built service can be passed directly to subdomains and services.
Global channels are addressable by any service or origin in any domain and any global service.</description>
    </item>
    
    <item>
      <title>Subdomains</title>
      <link>http://example.org/tutorial/subdomains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://example.org/tutorial/subdomains/</guid>
      <description>Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.
We will create a subdomain that mirrors the root domain. It will have a hello service and use the global world service and requests channel. The origin will have an endpoint that calls these services and constructs the response.</description>
    </item>
    
  </channel>
</rss>