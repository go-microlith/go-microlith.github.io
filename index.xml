<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microlith</title>
    <link>http://microlith-framework.com/</link>
    <description>Recent content on Microlith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 18:00:28 -0600</lastBuildDate>
    
	<atom:link href="http://microlith-framework.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tutorial</title>
      <link>http://microlith-framework.com/examples/tutorial/</link>
      <pubDate>Thu, 25 Oct 2018 18:58:57 -0600</pubDate>
      
      <guid>http://microlith-framework.com/examples/tutorial/</guid>
      <description>The complete code from the tutorial is available in the  tutorial.com repository.
Clone The repository should be cloned to the root of your Go workspace&amp;rsquo;s source tree, i.e. ${GOPATH}/src/tutorial.com.
# Clone the repo to the root of your Go workspace&#39;s source tree mkdir -p &amp;quot;${GOPATH}/src/tutorial.com&amp;quot; git clone https://github.com/go-microlith/tutorial.com &amp;quot;${GOPATH}/src/tutorial.com&amp;quot; # Microlith will recreate this rm -rf &amp;quot;${GOPATH}/src/tutorial.com/.git/&amp;quot; # Build the application go install tutorial.com  Bootstrap Assuming you own the domain name my-domain.</description>
    </item>
    
    <item>
      <title>Microservices</title>
      <link>http://microlith-framework.com/design/microservices/</link>
      <pubDate>Thu, 25 Oct 2018 18:18:21 -0600</pubDate>
      
      <guid>http://microlith-framework.com/design/microservices/</guid>
      <description>Microlith uses a microservices-based model called the Domain model. It has three main concepts: Services, Domains, and Applications.
Services Services are atomic units of business logic and are the base building block of a Microlith application.
Services are implemented as AWS::Serverless services, containing resources such as Buckets, Tables, and Streams to store and communicate state.
A service&amp;rsquo;s external interface is a REST API. Endpoints on the API implement business logic by manipulating buckets, mutating tables, and publishing to streams.</description>
    </item>
    
    <item>
      <title>Buckets</title>
      <link>http://microlith-framework.com/resources/blob/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/blob/</guid>
      <description>Create a bucket by calling Bucket() on a service builder with a unique bucket name.
images := service.Bucket(&amp;quot;images&amp;quot;)  The returned object is used to create clients and to attach observers.
Manipulators To Get(), Put(), or Delete() an object from a bucket, use a Manipulator.
mnip := blob.NewManipulator(images) contents, err := mnip.Get(ctx, &amp;quot;/microlith/logo.png&amp;quot;) if err != nil { log.Panic(err) } defer contents.Close() os.Copy(os.Stdout, contents)  Observers Observe objects added, updated, or deleted from buckets by calling the Observer() function on a service builder, giving it a unique observer name and an S3 Lambda function.</description>
    </item>
    
    <item>
      <title>Get Microlith</title>
      <link>http://microlith-framework.com/bootstrap/go_get/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/bootstrap/go_get/</guid>
      <description>Microlith is a standard Go library. Just use &amp;ldquo;go get&amp;rdquo;:
go get gopkg.in/microlith.v0  </description>
    </item>
    
    <item>
      <title>Hello, world!</title>
      <link>http://microlith-framework.com/tutorial/root/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/root/</guid>
      <description>We will be creating a Hello World application. Our application needs to respond to GET / with a 200 and the string &amp;ldquo;Hello, world!&amp;rdquo;. As we refactor the application throughout the tutorial, it should still return the same response.
To start, we will add a single &amp;ldquo;Hello, world!&amp;rdquo; endpoint to our application and redeploy. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level microlith package.</description>
    </item>
    
    <item>
      <title>Blog</title>
      <link>http://microlith-framework.com/examples/blog/</link>
      <pubDate>Thu, 25 Oct 2018 18:58:57 -0600</pubDate>
      
      <guid>http://microlith-framework.com/examples/blog/</guid>
      <description>A blogging application with social features is available in the  blog.com repository.
It provides a basic API for performing CRUD operations on blog posts. It extends this API with comments on blog posts and with Facebook-style reactions (&amp;ldquo;Like&amp;rdquo;, &amp;ldquo;Love&amp;rdquo;, etc.) on both posts and comments.
Clone The repository should be cloned to the root of your Go workspace&amp;rsquo;s source tree, i.e. ${GOPATH}/src/blog.com:
# Clone the repo to the root of your Go workspace&#39;s source tree mkdir -p &amp;quot;${GOPATH}/src/blog.</description>
    </item>
    
    <item>
      <title>Monolith</title>
      <link>http://microlith-framework.com/design/monolith/</link>
      <pubDate>Thu, 25 Oct 2018 18:18:21 -0600</pubDate>
      
      <guid>http://microlith-framework.com/design/monolith/</guid>
      <description>Microlith packages an entire application into a single executable binary. It does this by taking advantage of the init/main phase distinction in Go.
Microlith represents a Domain model application as a tree of Go objects. During the init phase, Microlith provides a builder DSL to construct this tree. Lambda functions are given as Go callback functions. The init phase ends when microlith.Main() is called.
The main phase handles converting the tree of objects into CloudFormation templates, deploying it to AWS in a Serverless pattern, and executing Lambda functions.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://microlith-framework.com/tutorial/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/services/</guid>
      <description>The origin API implements its business logic by making calls on services in the domain. It uses the results of those calls to create a response for the user.
Let&amp;rsquo;s refactor our domain into services which perform the work of creating words. Then we&amp;rsquo;ll refactor our origin endpoint to use those services to build our &amp;ldquo;Hello, world!&amp;rdquo; response.
The &amp;ldquo;word&amp;rdquo; Service We will create a &amp;ldquo;word&amp;rdquo; service that returns a fixed word.</description>
    </item>
    
    <item>
      <title>Streams</title>
      <link>http://microlith-framework.com/resources/strm/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/strm/</guid>
      <description>Create a stream by calling Stream() on a service builder with a unique stream name:
userSignups := service.Stream(&amp;quot;user-signups&amp;quot;)  The returned object is used to create clients and to attach processors.
Publishers To Publish() messages to a stream, use a Publisher. Publishers automatically batch messages. To ensure that any pending messages are published, defer a call to Flush().
publisher := strm.NewPublisher(userSignups) defer publisher.Flush(ctx) signup := &amp;amp;UserSignup{ Email: &amp;quot;john@doe.com&amp;quot;, At: time.</description>
    </item>
    
    <item>
      <title>Your First Application</title>
      <link>http://microlith-framework.com/bootstrap/create/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/bootstrap/create/</guid>
      <description>Microlith applications are a single Go executable that serves an entire top-level domain, such as example.com.
Create an Application To create an application, create an executable in ${GOPATH}/src/example.com/main.go and call microlith.Main():
package main import ( microlith &amp;quot;gopkg.in/microlith.v0&amp;quot; ) func main() { microlith.Main() }  The name of the executable is significant to Microlith. It must be named after the top-level domain name it logically serves. In this case, &amp;ldquo;example.com&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://microlith-framework.com/tutorial/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/channels/</guid>
      <description>Channels are streams shared between all services in a domain. Services use channels to communicate between each other. Any service can publish events to or process events from a channel. Additionally, the origin can publish events to a channel.
Let&amp;rsquo;s create a channel for request events. The &amp;ldquo;hello-world&amp;rdquo; endpoint in the origin will publish an event every request. The &amp;ldquo;word&amp;rdquo; service will process the events and write them out to the logs.</description>
    </item>
    
    <item>
      <title>Route53</title>
      <link>http://microlith-framework.com/bootstrap/route53/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/bootstrap/route53/</guid>
      <description>* Almost Zero Configuration
Microlith uses Route53 DNS as its global router. This requires a one-time, non-automatable setup. Once complete, the configuration can be reused for all of your Microlith applications.
You will need the Domain Name and the Hosted Zone ID to bootstrap your application. For the remainder of the documentation, we will assume you own my-domain.com in hosted zone Z1234567890.
 Domain Name You will need a domain name hosted in Route53.</description>
    </item>
    
    <item>
      <title>Tables</title>
      <link>http://microlith-framework.com/resources/stor/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/stor/</guid>
      <description>Create a table by calling the Table() method on a service builder.
Tables are created with a hash (&amp;ldquo;partition&amp;rdquo;) key and an optional range (&amp;ldquo;sort&amp;rdquo;) key given as Attributes. Attributes can be created with the StringAttribute(), NumberAttribute(), and BinaryAttribute() functions.
The streaming configuration must also be provided when the table is declared by passing a ChangeType value.
var artistKey = stor.StringAttribute(&amp;quot;Artist&amp;quot;) var nameKey = stor.StringAttribute(&amp;quot;Name&amp;quot;) var albums = service.Table(&amp;quot;albums&amp;quot;, artistKey, nameKey, stor.</description>
    </item>
    
    <item>
      <title>APIs</title>
      <link>http://microlith-framework.com/resources/rest/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/rest/</guid>
      <description>APIs follow the AWS API Gateway design, based on Swagger.
APIs Define paths in your API using the Scope() method. This method is available on service builders to define service APIs, on domain builders to define domain origins, and via microlith.Scope() to define the root domain&amp;rsquo;s origin API. Within your scopes, use methods named after HTTP methods to add endpoints.
Scopes Scopes are paths, such as &amp;ldquo;/foo&amp;rdquo; or &amp;ldquo;/bar&amp;rdquo;. Paths can be multiple segments, such as &amp;ldquo;/foo/bar&amp;rdquo; and can contain variables, such as &amp;ldquo;/foo/{foo-id}&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Bootstrap Your Application</title>
      <link>http://microlith-framework.com/bootstrap/bootstrap/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/bootstrap/bootstrap/</guid>
      <description>Your application has a built-in command to deploy itself into a self-hosted AWS environment. This environment includes a Git repository for your source code and a continuous deployment pipeline for your application with test and production environments. The bootstrap process will then initialize a git repository in your local source tree, create an initial commit, push, and wait for a full build and deploy to go green. Finally, it will healthcheck your deployed application.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://microlith-framework.com/tutorial/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/globals/</guid>
      <description>Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.
Global channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.
Let&amp;rsquo;s promote the &amp;ldquo;world&amp;rdquo; service to a global service and the &amp;ldquo;requests&amp;rdquo; channel to a global channel.
Promote the World Service To promote the &amp;ldquo;world&amp;rdquo; service, we need to use the microlith.</description>
    </item>
    
    <item>
      <title>Done</title>
      <link>http://microlith-framework.com/bootstrap/done/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/bootstrap/done/</guid>
      <description>Congratulations, your application is now bootstrapped! From now on, git push origin master deploys your application:
git add . git commit -m &amp;quot;My changes&amp;quot; git push origin master  If you receive a &amp;ldquo;403&amp;rdquo; when trying to push on Mac OS X, the credentials stored in the Keychain have expired. You will need to delete them to push again, as documented in Step 3 here.
 </description>
    </item>
    
    <item>
      <title>Schedued Jobs</title>
      <link>http://microlith-framework.com/resources/cron/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/cron/</guid>
      <description>Schedule a job to run in the background by calling Job() on a service builder, providing a unique job name, a schedule, and a CloudWatch Event Lambda function. The schedule can be a simple time interval or a complex calendar, both expressed using CloudWatch Schedule Expressions.
service.Job(&amp;quot;purge-cache&amp;quot;, &amp;quot;rate(15 minutes)&amp;quot;, func(ctx context.Context, evt events.CloudWatchEvent) error { return json.NewEncoder(os.Stdout).Encode(evt.Details) })  </description>
    </item>
    
    <item>
      <title>Subdomains</title>
      <link>http://microlith-framework.com/tutorial/subdomains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/subdomains/</guid>
      <description>Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.
Let&amp;rsquo;s create a subdomain named &amp;ldquo;sub.domain&amp;rdquo; that returns &amp;ldquo;Hello, subdomain world!&amp;rdquo;. It will have a &amp;ldquo;hello&amp;rdquo; service and use the global &amp;ldquo;world&amp;rdquo; service and &amp;ldquo;requests&amp;rdquo; channel. The subdomain&amp;rsquo;s origin will have an endpoint that calls these services and constructs the response.</description>
    </item>
    
    <item>
      <title>Log Readers</title>
      <link>http://microlith-framework.com/resources/inst/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/resources/inst/</guid>
      <description>All console output (standard out and standard error) from Lambdas is captured as CloudWatch Logs. Read Lambdas&amp;rsquo; logs by calling the Reader() method on a service builder, passing a unique reader name and a CloudWatch Logs Lambda function. Use the returned reader to filter and Read() a Lambda&amp;rsquo;s logs.
onErrors := service.Reader(&amp;quot;on-errors&amp;quot;, func(ctx context.Context, evt events.CloudwatchLogsEvent) error { data, err := evt.AWSLogs.Parse() if err != nil { return err } for _, logEvent := range data.</description>
    </item>
    
  </channel>
</rss>