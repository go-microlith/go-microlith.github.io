<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on Microlith</title>
    <link>http://microlith-framework.com/tutorial/</link>
    <description>Recent content in Tutorial on Microlith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 18:22:27 -0600</lastBuildDate>
    
	<atom:link href="http://microlith-framework.com/tutorial/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Hello, world!</title>
      <link>http://microlith-framework.com/tutorial/root/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/root/</guid>
      <description>We will be creating a Hello World application. Our application needs to respond to GET / with a 200 and the string &amp;ldquo;Hello, world!&amp;rdquo;. As we refactor the application throughout the tutorial, it should still return the same response.
To start, we will add a single &amp;ldquo;Hello, world!&amp;rdquo; endpoint to our application and redeploy. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level microlith package.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://microlith-framework.com/tutorial/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/services/</guid>
      <description>The origin API implements its business logic by making calls on services in the domain. It uses the results of those calls to create a response for the user.
Let&amp;rsquo;s refactor our domain into services which perform the work of creating words. Then we&amp;rsquo;ll refactor our origin endpoint to use those services to build our &amp;ldquo;Hello, world!&amp;rdquo; response.
The &amp;ldquo;word&amp;rdquo; Service We will create a &amp;ldquo;word&amp;rdquo; service that returns a fixed word.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://microlith-framework.com/tutorial/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/channels/</guid>
      <description>Channels are streams shared between all services in a domain. Services use channels to communicate between each other. Any service can publish events to or process events from a channel. Additionally, the origin can publish events to a channel.
Let&amp;rsquo;s create a channel for request events. The &amp;ldquo;hello-world&amp;rdquo; endpoint in the origin will publish an event every request. The &amp;ldquo;word&amp;rdquo; service will process the events and write them out to the logs.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://microlith-framework.com/tutorial/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/globals/</guid>
      <description>Global services are addressable by all services and origins in any domain. The built service can be passed directly to subdomains and services.
Global channels are addressable by any service or origin in any domain and any global service. The returned reference can be passed to domains and services.
Let&amp;rsquo;s promote the &amp;ldquo;world&amp;rdquo; service to a global service and the &amp;ldquo;requests&amp;rdquo; channel to a global channel.
Promote the World Service To promote the &amp;ldquo;world&amp;rdquo; service, we need to use the microlith.</description>
    </item>
    
    <item>
      <title>Subdomains</title>
      <link>http://microlith-framework.com/tutorial/subdomains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/subdomains/</guid>
      <description>Creating a subdomain is similar to creating a service. At the code level, a subdomain is an object that implements the tld.DomainBuilder interface and is registered under the root domain.
Let&amp;rsquo;s create a subdomain named &amp;ldquo;sub.domain&amp;rdquo; that returns &amp;ldquo;Hello, subdomain world!&amp;rdquo;. It will have a &amp;ldquo;hello&amp;rdquo; service and use the global &amp;ldquo;world&amp;rdquo; service and &amp;ldquo;requests&amp;rdquo; channel. The subdomain&amp;rsquo;s origin will have an endpoint that calls these services and constructs the response.</description>
    </item>
    
  </channel>
</rss>