<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on Microlith</title>
    <link>http://microlith-framework.com/tutorial/</link>
    <description>Recent content in Tutorial on Microlith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Oct 2018 18:22:27 -0600</lastBuildDate>
    
	<atom:link href="http://microlith-framework.com/tutorial/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Root Domain</title>
      <link>http://microlith-framework.com/tutorial/root/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/root/</guid>
      <description>We will be creating a Hello World application. Our application needs to respond to GET / with a 200 and the string &amp;ldquo;Hello, world!&amp;rdquo;. As we refactor the application throughout the tutorial, it should still return the same response.
To start, we will add a single &amp;ldquo;Hello, world!&amp;rdquo; endpoint to our application and redeploy. We will add the endpoint to the origin of the root domain. The root domain has a specialized API exposed via the top-level microlith package.</description>
    </item>
    
    <item>
      <title>Services</title>
      <link>http://microlith-framework.com/tutorial/services/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/services/</guid>
      <description>The origin API implements its business logic by making calls on services in the domain. It uses the results of those calls to create a response for the user.
Let&amp;rsquo;s refactor our domain into services which perform the work of creating words. Then we&amp;rsquo;ll refactor our origin endpoint to use those services to build our &amp;ldquo;Hello, world!&amp;rdquo; response.
The &amp;ldquo;word&amp;rdquo; Service We will create a &amp;ldquo;word&amp;rdquo; service that returns a fixed word.</description>
    </item>
    
    <item>
      <title>Channels</title>
      <link>http://microlith-framework.com/tutorial/channels/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/channels/</guid>
      <description>Channels are streams shared between all services in a domain. Services use channels to communicate between each other. Any service can publish events to or process events from a channel. Additionally, the origin can publish events to a channel.
Let&amp;rsquo;s create a channel for request events. The &amp;ldquo;hello-world&amp;rdquo; endpoint in the origin will publish an event every request. The &amp;ldquo;word&amp;rdquo; service will process the events and write them out to the logs.</description>
    </item>
    
    <item>
      <title>Subdomains</title>
      <link>http://microlith-framework.com/tutorial/subdomains/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/subdomains/</guid>
      <description>An application contains a root domain and a set of named subdomains.
Let&amp;rsquo;s create a subdomain named &amp;ldquo;sub.domain&amp;rdquo; that mirrors the root domain. It will have one endpoint that returns &amp;ldquo;Hello, subdomain world!&amp;rdquo;. Like the root domain, it will factor the work out into a &amp;ldquo;hello&amp;rdquo; and a &amp;ldquo;world&amp;rdquo; service and have a channel for request events. It will also have a public client method to call the endpoint on the origin.</description>
    </item>
    
    <item>
      <title>Globals</title>
      <link>http://microlith-framework.com/tutorial/globals/</link>
      <pubDate>Thu, 25 Oct 2018 18:10:01 -0600</pubDate>
      
      <guid>http://microlith-framework.com/tutorial/globals/</guid>
      <description>An application provides global services to share business logic between domains. It also provides global channels to communicate between different domains.
Let&amp;rsquo;s factor some shared logic out of our application by promoting the &amp;ldquo;world&amp;rdquo; service to a global service. Since the service relies on the requests channel, it will need to be promoted to a global channel. When we are done, both the root domain and the subdomain will each have their own &amp;ldquo;hello&amp;rdquo; service and will use the global &amp;ldquo;world&amp;rdquo; service and &amp;ldquo;requests&amp;rdquo; channel.</description>
    </item>
    
  </channel>
</rss>